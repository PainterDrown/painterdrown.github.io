<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>计算机视觉学习笔记：R-CNN</title>
      <link href="/cv/R-CNN/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="paper.pdf">Rich feature hierarchies for accurate object detection and semantic segmentation Tech report (v5)</a></p></blockquote><blockquote><p><a href="https://github.com/rbgirshick/rcnn" target="_blank" rel="external">Github source code in Matlab</a></p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>物体检测（Object Detection）的发展在 2012 年出现了停滞的现象，直到 R-CNN 方法的出现。在此之前，最好的方法是”The best-performing methods are complex ensemble systems that typically combine multiple low-level image features with high-level context.”，相比于这个方法，R-CNN 的特点是更为简单(simple)、可拓展性更强(scalable)。</p><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ol><li><p>one can apply high-capacity convolutional neural networks (CNNs) to bottom-up region proposals in order to localize and segment objects. 将一个高容量的 CNN（自底向上的区域建议）模型应用于图像物体定位和分割。</p></li><li><p>when labeled training data is scarce, supervised pre-training for an auxiliary task, followed by domain-specific fine-tuning, yields a significant performance boost. 当训练的数据很稀缺的时候，可以通过有监督的预训练，接着是 domain-specific（不知道怎么翻译比较好） 的微调（微调在这里是指将已有的用于图像分类的 CNN 模型进行参数的微调，从而使得该模型能够用于物体检测），从而达到一个明显的性能提升效果。</p></li></ol><h2 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h2><p><img src="/cv/R-CNN/images/rcnn.png" alt="rcnn"></p><ol><li>Takes an input image. 输入图像。</li><li>Extracts around 2000 bottom-up region proposals. 提取约 2000 个自底向上的区域建议。</li><li>Compute features for each proposals using a large CNN. 将每一个区域输入 CNN，得到特征（固定长度）。</li><li>Classifies each region using class-specific linear SVMs. 对于上一步得到的每一个区域的特征，用线性 SVM 进行分类。</li></ol><h2 id="R-CNN-简介"><a href="#R-CNN-简介" class="headerlink" title="R-CNN 简介"></a>R-CNN 简介</h2><ul><li>R-CNN 总共有 5 个卷积层，输入像素块大小为 195 <em> 195，步长为 32 </em> 32，另外有 2 个全连接层。</li><li>R-CNN 其实就是在 CNN 的基础之上加了 “recognition using regions” paradigm，这样更适合做物体检测和语义分割。</li><li>R-CNN 中每一个区域得到的特征都是定长的。</li><li>面临训练数据很少的问题，传统的方法是先进行无监督的预训练，接着是有监督的微调。而 R-CNN 则是先在大的辅助数据集上进行有监督的预训练，然后在小数据集上进行 domain-specific 的微调。</li><li>R-CNN 中，主导错误模式的因素是 bounding-box regression method，因为这个方法能有效地提高物体定位的准确率。</li><li>R-CNN 的计算效率比较高，主要体现在两部分：一是 SVM 中的矩阵向量乘法规模比较小；另外一部分则是 greedy non-maximum suppression。</li></ul><h2 id="R-CNN-物体检测"><a href="#R-CNN-物体检测" class="headerlink" title="R-CNN 物体检测"></a>R-CNN 物体检测</h2><h3 id="1-模块设计"><a href="#1-模块设计" class="headerlink" title="1. 模块设计"></a>1. 模块设计</h3><h4 id="1-1-区域建议"><a href="#1-1-区域建议" class="headerlink" title="1.1 区域建议"></a>1.1 区域建议</h4><p>已经有很多的论文提出了 category-independent（分类无关的）生产区域建议的方法。R-CNN 采用的是 Selective Search。</p><h4 id="1-2-特征提取"><a href="#1-2-特征提取" class="headerlink" title="1.2 特征提取"></a>1.2 特征提取</h4><p>R-CNN 使用的是 Krizhevsky 的 CNN 模型，提取出 4096 维的特征向量。在此之前，对于每一个区域，先通过 Affine Transform 转换成 227 * 227 的正方形，再输入 CNN 模型。</p><h3 id="2-测试时检测"><a href="#2-测试时检测" class="headerlink" title="2. 测试时检测"></a>2. 测试时检测</h3><p>测试过程：Selective Search -&gt; 2000 region proposals -&gt; CNN -&gt; SVM -&gt; greedy non-maximum suppression。</p><p>做 greedy non-maximum suppression 是来过滤掉一些区域（这些区域的 IoU 大于某个学习得到的阈值，意思是如果两个区域重叠的部分过多，则淘汰掉得分较低的那一个）。</p><p>特征矩阵(2000 <em> 4096) </em> SVM 权重矩阵(4096 <em> N，N 代表图片的分类总数) = 分类得分矩阵(2000 </em> N)。</p><h3 id="3-训练"><a href="#3-训练" class="headerlink" title="3 训练"></a>3 训练</h3><p><strong>有监督的预训练。</strong>把 CNN 放在大的数据集上进行训练，这个数据集的 label 都是 image-level 的，意思就是说数据集中的图片的标注只是”这是一张关于猫的图片”，而不是”这张图片中在 xxx 有一只猫，在 xxx 有 xxx”。也就是说，这个训练集的标注信息跟我们做物体检测理想的训练集标注信息不一样。</p><p><strong>Domain-specific 微调。</strong>为了将上面的 CNN 应用于新的任务（物体检测）以及新的作用域(warped proposal windows)，用 SGD 来训练 CNN 的参数。将 CNN 中 ImageNet 1000-way 分类层替换成随机初始化的 (N+1)-way 分类层。除此之外，保留 CNN 的其他结构。将 IoU &gt;= 0.5 的区域视为正样本，否则视为负样本。SGD 的学习比率为 0.001，在每个 SGD 的迭代中，采样方法为：32 正样本 + 96 负样本（背景）= 128 mini batch。</p><p><strong>物体类别分类器。</strong>如果某个区域中包含了汽车的一部分，如何将这个区域标定为汽车检测的正样本？解决的方法是 IoU overlap threshold。经过调试可以得知 threshold 取 0.3 时效果最好。</p><h2 id="可视化、消融、错误模式"><a href="#可视化、消融、错误模式" class="headerlink" title="可视化、消融、错误模式"></a>可视化、消融、错误模式</h2><ol><li><p><strong>可视化学习特征。</strong>第一层的结果可以直接可视化，也很容易进行理解。对于其他的层，Zeiler and Fergus 提供了相应的方法。基本思想是对检测器的得分进行排序，而不进行平均化处理，而是关注它们的激活条件。</p></li><li><p><strong>消融学习。</strong>从模型中减少某些层，看减少之后的影响，从而来表现减少地那一层在整个 R-CNN 中的作用。论文从有无微调的维度上进行 layer-by-layer 的消融学习。</p></li><li><p><strong>网络架构。</strong>像之前提到的，CNN 只是在 Krizhevsky 的基础之上进行微调，因此 R-CNN 的网络架构跟其很像。衍生出 O-Net 和 N-Net，前者的 mAP 得分更高，但是花费的时间却是后者的 7 倍。</p></li><li><p><strong>检测错误分析。</strong>利用 Hoiem et al 的错误分析工具。</p></li><li><p><strong>Bounding-box 回归。</strong>受到 DMP 的启发，R-CNN 训练一个线性回归模型来预测一个新的检测窗口（已知 pool5 层输出的特征之后）。</p></li></ol>]]></content>
      
      
        <tags>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统分析与设计 Assignment 6</title>
      <link href="/saad/assignment-6/"/>
      <content type="html"><![CDATA[<h2 id="使用-UML-State-Model"><a href="#使用-UML-State-Model" class="headerlink" title="使用 UML State Model"></a>使用 UML State Model</h2><p>建模对象： 参考 Asg_RH 文档， 对 Reservation/Order 对象建模。<br>建模要求： 参考练习不能提供足够信息帮助你对订单对象建模，请参考现在 定旅馆 的旅游网站，尽可能分析围绕订单发生的各种情况，直到订单通过销售事件（柜台销售）结束订单。</p><p>状态集合 S = { wating for check up, checked up, paid, granted, invoiced }。</p><p>事件集合 E = { new reservation, make changes, check the order, pay for the order, manager grant, invoice, user cancel, time out, manager cancel }。</p><p><img src="/saad/assignment-6/images/usm.png" alt="usm"></p><h2 id="研究天猫退货流程活动图，对退货业务对象状态建模"><a href="#研究天猫退货流程活动图，对退货业务对象状态建模" class="headerlink" title="研究天猫退货流程活动图，对退货业务对象状态建模"></a>研究天猫退货流程活动图，对退货业务对象状态建模</h2><p><img src="/saad/assignment-6/images/taobao.png" alt="tianmao"></p>]]></content>
      
      
        <tags>
            
            <tag> saad </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统分析与设计 Assignment 5</title>
      <link href="/saad/assignment-5/"/>
      <content type="html"><![CDATA[<h2 id="按用例构建领域模型"><a href="#按用例构建领域模型" class="headerlink" title="按用例构建领域模型"></a>按用例构建领域模型</h2><p><img src="/saad/assignment-5/images/lingyu.png" alt=""></p><h2 id="数据库建模（E-R-模型）"><a href="#数据库建模（E-R-模型）" class="headerlink" title="数据库建模（E-R 模型）"></a>数据库建模（E-R 模型）</h2><p><img src="/saad/assignment-5/images/db.png" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> consumer </div><div class="line">(</div><div class="line">   <span class="keyword">name</span>                 <span class="built_in">char</span>(<span class="number">20</span>)                       <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">   email                <span class="built_in">char</span>(<span class="number">50</span>)                       <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">   <span class="keyword">constraint</span> PK_CONSUMER primary <span class="keyword">key</span> clustered (<span class="keyword">name</span>)</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> hotel </div><div class="line">(</div><div class="line">   <span class="keyword">name</span>                 <span class="built_in">char</span>(<span class="number">50</span>)                       <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">   star                 <span class="built_in">decimal</span>                        <span class="literal">null</span>,</div><div class="line">   <span class="string">"index"</span>              <span class="built_in">char</span>(<span class="number">20</span>)                       <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">   code                 <span class="built_in">char</span>(<span class="number">20</span>)                       <span class="literal">null</span>,</div><div class="line">   address              <span class="built_in">dec</span>(<span class="number">50</span>)                        <span class="literal">null</span>,</div><div class="line">   <span class="keyword">constraint</span> PK_HOTEL primary <span class="keyword">key</span> clustered (<span class="string">"index"</span>)</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> location </div><div class="line">(</div><div class="line">   code                 <span class="built_in">char</span>(<span class="number">20</span>)                       <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">   <span class="keyword">name</span>                 <span class="built_in">char</span>(<span class="number">50</span>)                       <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">   <span class="keyword">constraint</span> PK_LOCATION primary <span class="keyword">key</span> clustered (code, <span class="keyword">name</span>)</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> request </div><div class="line">(</div><div class="line">   <span class="string">"hotel name"</span>         <span class="built_in">char</span>(<span class="number">50</span>)                       <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">   city                 <span class="built_in">char</span>(<span class="number">20</span>)                       <span class="literal">null</span>,</div><div class="line">   <span class="string">"room type"</span>          <span class="built_in">char</span>(<span class="number">10</span>)                       <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">   <span class="string">"check in date"</span>      datetime                       <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">   <span class="string">"check out date"</span>     datetime                       <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">   hotel_index          <span class="built_in">char</span>(<span class="number">20</span>)                       <span class="literal">null</span>,</div><div class="line">   con_name             <span class="built_in">char</span>(<span class="number">20</span>)                       <span class="literal">null</span>,</div><div class="line">   special              <span class="built_in">char</span>(<span class="number">100</span>)                      <span class="literal">null</span>,</div><div class="line">   <span class="string">"request index"</span>      <span class="built_in">char</span>(<span class="number">20</span>)                       <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">   <span class="keyword">constraint</span> PK_REQUEST primary <span class="keyword">key</span> clustered (<span class="string">"check in date"</span>, <span class="string">"check out date"</span>, <span class="string">"request index"</span>)</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> room </div><div class="line">(</div><div class="line">   <span class="string">"room id"</span>            <span class="built_in">char</span>(<span class="number">10</span>)                       <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">   <span class="string">"hotel index"</span>        <span class="built_in">char</span>(<span class="number">20</span>)                       <span class="literal">null</span>,</div><div class="line">   <span class="keyword">type</span>                 <span class="built_in">char</span>(<span class="number">20</span>)                       <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">   <span class="string">"availble num"</span>       <span class="built_in">decimal</span>                        <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">   <span class="keyword">constraint</span> PK_ROOM primary <span class="keyword">key</span> clustered (<span class="string">"room id"</span>)</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">"room description"</span> </div><div class="line">(</div><div class="line">   <span class="string">"room id"</span>            <span class="built_in">char</span>(<span class="number">10</span>)                       <span class="literal">null</span>,</div><div class="line">   <span class="keyword">type</span>                 <span class="built_in">char</span>(<span class="number">20</span>)                       <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">   <span class="string">"list price"</span>         <span class="keyword">double</span>                         <span class="keyword">not</span> <span class="literal">null</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> hotel</div><div class="line">   <span class="keyword">add</span> <span class="keyword">constraint</span> FK_HOTEL_REFERENCE_LOCATION foreign <span class="keyword">key</span> (code, <span class="keyword">name</span>)</div><div class="line">      <span class="keyword">references</span> location (code, <span class="keyword">name</span>)</div><div class="line">      <span class="keyword">on</span> <span class="keyword">update</span> restrict</div><div class="line">      <span class="keyword">on</span> <span class="keyword">delete</span> restrict;</div><div class="line"></div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> request</div><div class="line">   <span class="keyword">add</span> <span class="keyword">constraint</span> FK_REQUEST_REFERENCE_HOTEL foreign <span class="keyword">key</span> (hotel_index)</div><div class="line">      <span class="keyword">references</span> hotel (<span class="string">"index"</span>)</div><div class="line">      <span class="keyword">on</span> <span class="keyword">update</span> restrict</div><div class="line">      <span class="keyword">on</span> <span class="keyword">delete</span> restrict;</div><div class="line"></div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> request</div><div class="line">   <span class="keyword">add</span> <span class="keyword">constraint</span> FK_REQUEST_REFERENCE_CONSUMER foreign <span class="keyword">key</span> (con_name)</div><div class="line">      <span class="keyword">references</span> consumer (<span class="keyword">name</span>)</div><div class="line">      <span class="keyword">on</span> <span class="keyword">update</span> restrict</div><div class="line">      <span class="keyword">on</span> <span class="keyword">delete</span> restrict;</div><div class="line"></div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> room</div><div class="line">   <span class="keyword">add</span> <span class="keyword">constraint</span> FK_ROOM_REFERENCE_HOTEL foreign <span class="keyword">key</span> (<span class="string">"hotel index"</span>)</div><div class="line">      <span class="keyword">references</span> hotel (<span class="string">"index"</span>)</div><div class="line">      <span class="keyword">on</span> <span class="keyword">update</span> restrict</div><div class="line">      <span class="keyword">on</span> <span class="keyword">delete</span> restrict;</div><div class="line"></div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">"room description"</span></div><div class="line">   <span class="keyword">add</span> <span class="keyword">constraint</span> <span class="string">"FK_ROOM DES_REFERENCE_ROOM"</span> foreign <span class="keyword">key</span> (<span class="string">"room id"</span>)</div><div class="line">      <span class="keyword">references</span> room (<span class="string">"room id"</span>)</div><div class="line">      <span class="keyword">on</span> <span class="keyword">update</span> restrict</div><div class="line">      <span class="keyword">on</span> <span class="keyword">delete</span> restrict;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> saad </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统分析与设计 Assignment 4</title>
      <link href="/saad/assignment-4/"/>
      <content type="html"><![CDATA[<h2 id="用例建模"><a href="#用例建模" class="headerlink" title="用例建模"></a>用例建模</h2><ol><li>阅读Asg_RH文档，绘制用例图。按照Task1要求，请使用工具UMLet，截图格式务必是png并控制尺寸</li></ol><p><img src="/saad/assignment-4/images/1a.png" alt=""></p><ol><li>选择你熟悉的定旅馆在线服务系统（或移动App），如如绘制用例图。</li></ol><p><img src="/saad/assignment-4/images/1b.png" alt=""></p><ol><li><p>对比两个时代、不同地区产品的用例图，总结在项目早期，发现创新的思路与方法 在项目早期的创新往往需要参考以往已经存在的类似产品，了解这些产品的功能，画出它们的用例图，确定基本实现思路，要实现创新还需要通过调查了解各种顾客对产品的需求，考虑不同人群对产品的需求，来添加一些其他产品没有考虑的功能和用例。</p></li><li><p>请使用SCRUM方法，在(任务b)用例图基础上，编制某定旅馆开发的需求(backlog)。</p></li></ol><ul><li>搜索酒店：在首页选择城市、入住和退房日期， 选填关键词、酒店等级，点击搜索按钮</li><li>预定酒店：在酒店列表点击表项进入酒店详情页面，查看酒店可订的房型、相应日期、酒店地址，点击预定按钮</li><li>确认订单：查看详细订单，修改房间数量、预计到店时间，可选择购买保险，填写手机号码选填邮箱确认订单</li><li>付款：选择付款方式，进行付款</li></ul><h2 id="业务建模"><a href="#业务建模" class="headerlink" title="业务建模"></a>业务建模</h2><ol><li>在(任务b)的基础上，用活动图建模找酒店用例。简述利用流程图发现子用例的方法。</li></ol><p><img src="/saad/assignment-4/images/2a.png" alt=""></p><ol><li>选择你身边的银行ATM，用活动图描绘取款业务。</li></ol><p><img src="/saad/assignment-4/images/2b.png" alt=""></p><ol><li>查找淘宝退货业务官方文档，使用多泳道图，表达客户、淘宝网、淘宝商家服务系统、商家等用户和系统协同完成退货业务，在淘宝网上需要实现哪些系统用例。</li></ol><p><img src="/saad/assignment-4/images/2c.png" alt=""></p><h2 id="用例文本编写"><a href="#用例文本编写" class="headerlink" title="用例文本编写"></a>用例文本编写</h2><ul><li>Brief：一段简洁的摘要<ul><li>优点：简洁明了、易于编写</li><li>缺点：不够细致，只能提供粗略的分析</li></ul></li><li>Casual：非正式的覆盖多种场景的段落<ul><li>优点：较Brief用例文本详细，</li><li>缺点：不够正式</li></ul></li><li>Fully：详细地编写用例所有步骤和各种变化，同时补充前置条件和成功保证等。Fully用例文本通常用在以摘要形式编写了很多用例以后，详细地编写其中少量具有重要意义和价值的用例<ul><li>优点：细节充足，具有结构性</li><li>缺点：编写工作比较繁琐</li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> saad </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统分析与设计 Assignment 3</title>
      <link href="/saad/assignment-3/"/>
      <content type="html"><![CDATA[<h1 id="UML-活动图、用例图的学习笔记"><a href="#UML-活动图、用例图的学习笔记" class="headerlink" title="UML 活动图、用例图的学习笔记"></a>UML 活动图、用例图的学习笔记</h1><h2 id="UML-活动图"><a href="#UML-活动图" class="headerlink" title="UML 活动图"></a>UML 活动图</h2><p>我们在进行项目的时候，通过使用 UML 的面向对象图的方式来更明确、清晰的表达项目中的架设思想、项目结构、执行顺序等一些逻辑思维。UML 支持面向对象的技术，能够准确的方便地表达面向对像的概念，体现面向对象的分析和设计风格。</p><p>UML 的模型主要有三部分构成：</p><ul><li>事物(Things)：UML模型中最基本的构成元素，是具有代表性的成分的抽象；</li><li>关系(Relationships)：关系把事物紧密联系在一起；</li><li>图(Diagrams )：图是事物和关系的可视化表示。</li></ul><p>UML中有九种建模的图标，即：用例图、类图、对象图、顺序图、协作图、状态图、活动图、组件图、配置图。</p><h2 id="用例图（Use-Case-Diagram）"><a href="#用例图（Use-Case-Diagram）" class="headerlink" title="用例图（Use Case Diagram）"></a>用例图（Use Case Diagram）</h2><h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><p>参与者的定义：</p><ul><li>参与者可以是人或其他外界系统；</li><li>参与者时用力的启动者，参与者处于用例的外部并且能够初始化一个用例并参与用例的执行过程，但它并不是系统的一部分；</li><li>每个参与者可以参与一个或多个用例。</li></ul><p>如何寻找系统的参与者：</p><ul><li>谁或什么在使用系统；</li><li>交互中，他们扮演什么角色；</li><li>谁安装系统；</li><li>谁启动和关闭系统；</li><li>谁维护系统；</li><li>与该系统交互的是什么系统；</li><li>谁从系统获取信息，谁提供信息给系统。</li></ul><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><h4 id="包含关系-include"><a href="#包含关系-include" class="headerlink" title="包含关系 include"></a>包含关系 include</h4><p>把几个用例的公共步骤分离成一个单独被包含用例；包含用例称为客户用例，被包含用例称为提供者用例。用例A包含用例 B，将 A 称为基用例，B 称为被包含用例。基用例被连接在虚线箭头的尾部，箭头指向被包含用例，并在虚线处添加一个 include 标签以表示扩展关系。</p><h4 id="扩展关系-Extend"><a href="#扩展关系-Extend" class="headerlink" title="扩展关系 Extend"></a>扩展关系 Extend</h4><p>扩展使得每个用例可以通过扩展用例向基用例中添加额外的行为来扩展基用例的功能，扩展关系可以把一些可选的操作独立封装在另外的用例中，避免基用例过于复杂。用例A扩展了用例 B，那么 A 称为扩展用例或子用例，B 表示为基用例。扩展用例被连接在虚线箭头的尾部，箭头指向基用例，并在虚线处添加一个 extend 表示扩展关系。</p><h3 id="活动图的组成元素"><a href="#活动图的组成元素" class="headerlink" title="活动图的组成元素"></a>活动图的组成元素</h3><ol><li>活动状态图（Activity）</li><li>动作状态（Actions)</li><li>动作状态约束（Action Constraints）</li><li>动作流（Control Flow）</li><li>开始节点（Initial Node）</li><li>终止节点（Final Node）</li><li>对象（Objects）</li><li>数据存储对象</li><li>对象流（Object）</li><li>分支与合并（Decision and Merge Nodes</li><li>分叉与汇合（Fork and Join Nodes）</li><li>异常处理（Exception Handler）</li><li>活动中断区域（Interruptible Activity Region）</li><li>泳道（Partition）</li></ol><p>UML 活动图能够捕捉到该系统的动态行为，UML 中其它的四个图是用来显示从一个对象到另一个消息流，但活动图是用来显示消息流从一个活动到另一个活动图。活动图不仅用于可视化系统的动态性质，也可用于通过使用正向和逆向工程技术来构建可执行的系统。唯一缺少的东西在活动图的消息部分。它并不显示任何消息流程从一个活动到另一个。活动图是一段时间视为流程图。虽然图中看起来像一个流程图，但事实并非如此。它显示不同的流程，如并行，分支，并发单。</p><p>以下是 UML 活动图目的描述：</p><ul><li>绘制活动流程系统。</li><li>描述的顺序从一个活动到另一个。</li><li>描述系统并行，分支，并发流。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> saad </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机视觉学习笔记：Get Started</title>
      <link href="/cv/get-started/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今晚实验室老师开会，说打算开始带我和另外一位同学做 CV 以及神经网络。为了更系统地学习和记忆，接下来我打以博客的形式记录下学习过程及心得等等。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="http://open.163.com/special/opencourse/machinelearning.html" target="_blank" rel="external">吴恩达 (Andrew Ng) 关于机器学习的公开课</a></p></blockquote><blockquote><p><a href="http://www.ee.cuhk.edu.hk/~xgwang/" target="_blank" rel="external">王晓刚（香港中文大学）教授关于深度学习的课程</a></p></blockquote><blockquote><p><a href="http://study.163.com/course/courseMain.htm?courseId=1004697005" target="_blank" rel="external">李飞飞关于 CNN 的计算机视觉公开课</a></p></blockquote><h2 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h2><p>师兄提到玩计算机视觉必定要碰 OpenCV，所以这里讲一下我的安装过程。</p><h3 id="OpenCV-amp-C"><a href="#OpenCV-amp-C" class="headerlink" title="OpenCV &amp; C++"></a>OpenCV &amp; C++</h3><p>由于我用的是 macOS，比较方便的做法是：Xcode + OpenCV 的环境。</p><ol><li><p>使用 brew 安装：<code>brew install opencv</code></p></li><li><p>安装完之后，可以看到以下目录及文件：</p><ul><li>/usr/local/Cellar/opencv</li><li>/usr/local/include</li><li>/usr/local/lib</li></ul></li><li><p>Xcode 新建命令行程序项目，在工程文件下进行以下设置：</p><ul><li><p>Build Phases -&gt; Link Binary With Libraries 添加 /usr/local/Cellar/opencv/&lt;版本&gt;/lib 中的所有 .dylib 文件</p><p><img src="/cv/get-started/images/setting-1.png" alt="Build Phases"></p></li><li><p>Build Settings -&gt; Search Paths 添加 /usr/local/include 和 /usr/local/lib</p><p><img src="/cv/get-started/images/setting-2.png" alt="Build Settings"></p></li></ul></li><li><p>配置完毕，在 cpp 文件直接：<code>#include &quot;opencv2/opencv.hpp&quot;</code>，测试代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/opencv.hpp"</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    Mat image;</div><div class="line">    image = imread(<span class="string">"test.jpeg"</span>);  <span class="comment">// 这里换成图片的绝对路径</span></div><div class="line">    namedWindow(<span class="string">"Hello OpenCV!"</span>, WINDOW_AUTOSIZE);</div><div class="line">    imshow(<span class="string">"Hello OpenCV!"</span>, image);</div><div class="line">    waitKey(<span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h3 id="OpenCV-amp-Python"><a href="#OpenCV-amp-Python" class="headerlink" title="OpenCV &amp; Python"></a>OpenCV &amp; Python</h3><p>最近在看《OpenCV 3 计算机视觉 Python 语言实现》，里面需要搭 OpenCV + Python 的环境，此外要需要引入外部模块 contrib。为了满足这些条件，这次是用源码编译安装的。</p><ol><li>获取源码</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/opencv/opencv.git</div><div class="line">git <span class="built_in">clone</span> https://github.com/opencv/opencv_contrib.git</div><div class="line"><span class="built_in">cd</span> opencv</div><div class="line">mkdir build</div><div class="line"><span class="built_in">cd</span> build</div></pre></td></tr></table></figure><ol><li>编译、安装</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE \</div><div class="line">      -D CMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span> \</div><div class="line">      -D PYTHON2_PACKAGES_PATH=/usr/<span class="built_in">local</span>/lib/python2.7/site-packages \</div><div class="line">      -D OPENCV_EXTRA_MODULES_PATH=../../opencv_contrib/modules ..</div><div class="line">make -j4</div><div class="line">sudo make install</div></pre></td></tr></table></figure><ol><li>添加 python 连接关系</li></ol><pre><code class="sh"></code></pre>]]></content>
      
      
        <tags>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统分析与设计 Assignment 2</title>
      <link href="/saad/assignment-2/"/>
      <content type="html"><![CDATA[<h2 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h2><ul><li>简述瀑布模型、增量模型、螺旋模型（含原型方法）的优缺点。</li></ul><table><thead><tr><th>模型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>瀑布模型</td><td>定义了软件开发基本流程与活动：创意阶段（描述问题，市场，关键技术等）、分析阶段（用户故事、领域模型、业务流程等）</td><td>1. 依赖问题（前面需求模糊而影响后面工作） 2. 容错问题（在后期发现需求问题，工作量难接受） 3. 资源调配问题（知识技能需求不同、人员数量要求不同）</td></tr><tr><td>增量模型</td><td>1. 将待开发的软件系统模块化，可以分批次地提交软件产品，使用户可以及时了解软件项目的进展。 2. 以组件为单位进行开发降低了软件开发的风险。 3. 开发顺序灵活。</td><td>1. 并行开发构件有可能遇到不能集成的风险，软件必须具备开放式的体系结构。 2. 增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而是软件过程的控制失去整体性。</td></tr><tr><td>螺旋模型</td><td>1. 设计上的灵活性,可以在项目的各个阶段进行变更。 2. 以小的分段来构建大型系统,使成本计算变得简单容易。 3. 客户始终参与每个阶段的开发,保证了项目不偏离正确方向以及项目的可控性。 4. 随着项目推进,客户始终掌握项目的最新信息 , 从而他或她能够和管理层有效地交互。</td><td>1. 采用螺旋模型需要具有相当丰富的风险评估经验和专门知识，在风险较大的项目开发中，如果未能够及时标识风险，势必造成重大损失。 2. 过多的迭代次数会增加开发成本，延迟提交时间。</td></tr></tbody></table><ul><li><p>简述 UP 的三大特点，其中哪些内容体现了用户驱动的开发，哪些内容体现风险驱动的开发？</p><ol><li>用例驱动</li><li>以架构为中心</li><li>受控的迭代式增量开发</li></ol><p>前两者体现了用户驱动的开发，第三点体现了风险驱动的开发。</p></li><li><p>UP 四个阶段的划分准则是什么？关键的里程碑是什么？</p><ol><li>初始阶段：大体的构想、范围和模糊评估、用例，只详细编写最重要的部分用例。</li><li>细化阶段：核心架构的迭代实现，高风险用例的实现、确定大多数需求、范围以及更为准确的评估。</li><li>构造阶段：对遗留下来的风险较低的比较简单的元素迭代实现，准备部署。</li><li>移交阶段：进行 beta 测试和部署。</li></ol></li><li><p>IT 项目管理中，“工期、质量、范围/内容” 三个元素中，在合同固定条件下，为什么说“范围/内容”是项目团队是易于控制的</p><p>工期是在合同里面确定好的，项目的每一个阶段都有规定的完成时间，不能随意更改。而客户在合同中也规定好了项目的验收条件，质量也是不由团队控制的。范围/内容是由团队控制的，因为只有由团队来控制，项目才能够顺利完成。</p></li><li><p>为什么说，UP 为企业按固定节奏生产、固定周期发布软件产品提供了依据？</p><p>软件开发生命周期根据时间（固定周期发布）和 RUP 的核心工作流（固定节奏生产）划分为二维空间。时间维从组织管理的角度描述整个软件开发生命周期，是RUP的动态组成部分，核心工作流从技术角度描述RUP的静态组成部分。</p></li></ul><h2 id="项目管理使用"><a href="#项目管理使用" class="headerlink" title="项目管理使用"></a>项目管理使用</h2><blockquote><p><a href="https://tower.im/projects/8d7d7a72725242b3beb1609174e058ba/" target="_blank" rel="external">https://tower.im/projects/8d7d7a72725242b3beb1609174e058ba/</a></p></blockquote><ul><li><p>团队任务</p><p><img src="/saad/assignment-2/images/team.png" alt=""></p></li><li><p>个人任务</p><p><img src="/saad/assignment-2/images/person.png" alt=""></p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> saad </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统分析与设计 Assignment 1</title>
      <link href="/saad/assignment-1/"/>
      <content type="html"><![CDATA[<h2 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h2><ul><li><p>软件工程的定义</p><p>将系统化、规范化、可度量的方法应用与软件的开发、运行和维护的过程， 即将工程化应用于软件中。</p></li><li><p>阅读经典名著“人月神话”等资料，解释 software crisis、COCOMO 模型。</p><p>软件危机是指六十年代以来，随着计算机应用需求的驱动，系统软件和应用软件有很大的发展，如操作系统，编译系统和大型应用软件等。由于软件生产的复杂性和高成本，使大型软件的生产出现了很大的困难，即出现软件危机。</p><p>COCOMO模型是由TRW公司开发，Boehm提出的结构化成本估算模型。是一种精确的、易于使用的成本估算方法。模型按其详细程度可以分为三级：基本COCOMO模型，中间COCOMO模型，详细COCOMO模型。其中：</p><ul><li>基本COCOMO模型是是一个静态单变量模型，它用一个以已估算出来的原代码行数(LOC)为自变量的经验函数计算软件开发工作量。 </li><li>中级COCOMO模型在基本COCOMO模型的基础上，再用涉及产品、硬件、人员、项目等方面的影响因素调整工作量的估算。</li><li>详细COCOMO模型包括中间COCOMO模型的所有特性，但更进一步考虑了软件工程中每一步骤（如分析、设计）的影响。</li></ul></li></ul><ul><li><p>软件生命周期。</p><p>在软件的开发过程中，各阶段的任务彼此间尽可能相对独立，同一个阶段各项任务的性质尽可能相同，从而降低每个阶段任务的复杂性，简化不同阶段之间的联系，有利于软件开发过程的组织管理。受软件规模、性质、种类、开发方法等因素的影响。典型划分GB8567(4个时期7个阶段):</p><ol><li>软件分析时期:问题定义、可行性研究、需求分析</li><li>软件设计时期:总体设计、详细设计</li><li>编码与测试时期:编码、测试</li><li>运行与维护时期</li></ol></li><li><p>按照 SWEBok 的 KA 划分，本课程关注哪些 KA 或 知识领域？</p><p>本课程关注的 SWEBOK 中的 KA 有：</p><ul><li>软件需求(Software Requirements)</li><li>软件设计(Software Design)</li><li>软件构筑(Software Construction)</li></ul></li><li><p>解释 CMMI 的五个级别。例如：Level 1 - Initial：无序，自发生产模式。</p><ol><li>初始级。软件过程是无序的，有时甚至是混乱的，对过程几乎没有定义，成功取决于个人努力。管理是反应式的。</li><li>可重复级。建立了基本的项目管理过程来跟踪费用、进度和功能特性。制定了必要的过程纪律，能重复早先类似应用项目取得的成功经验。</li><li>已定义级。已将软件管理和工程两方面的过程文档化、标准化，并综合成该组织的标准软件过程。所有项目均使用经批准、剪裁的标准软件过程来开发和维护软件，软件产品的生产在整个软件过程是可见的。</li><li>量化管理级。分析对软件过程和产品质量的详细度量数据，对软件过程和产品都有定量的理解与控制。管理有一个作出结论的客观依据，管理能够在定量的范围内预测性能。</li><li>优化管理级。过程的量化反馈和先进的新思想、新技术促使过程持续不断改进。</li></ol></li><li><p>用自己语言简述 SWEBok 或 CMMI （约200字）</p><p>在我的理解中，SWEBOK 是软件工程专业一个具有纲领性意义的指南，比较全面地介绍了软件工程所涉及到的知识领域以及辅助领域，这个知识体系是软件工程向职业状态演化的关键。SWEBOK 描述的是广泛共识的知识，随着软件技术的迅速发展，当前一些学术界的研究成果以及产业开始应用的新技术将逐渐普及。Google 一下之后知道了 SWEBOK V3 项目组的最后一个目标是希望能建立 SWEBOK 每三年周期性更新的制度，持续改进知识体系。期待SWEBOK能成为持续推进软件工程走向成熟的重要力量之一。 </p></li></ul><h2 id="解释-PSP-各项指标及技能要求"><a href="#解释-PSP-各项指标及技能要求" class="headerlink" title="解释 PSP 各项指标及技能要求"></a>解释 PSP 各项指标及技能要求</h2><ul><li><p>阅读《现代软件工程》的 PSP: Personal Software Process 章节。<br><a href="http://www.cnblogs.com/xinz/archive/2011/11/27/2265425.html" target="_blank" rel="external">http://www.cnblogs.com/xinz/archive/2011/11/27/2265425.html</a></p><p>已阅。</p></li><li><p>按表格 PSP 2.1， 了解一个软件工程师在接到一个任务之后要做什么，需要哪些技能，解释你打算如何统计每项数据？ （期末考核，每人按开发阶段提交这个表）</p><ul><li>计划（Planning）<ul><li>估计这个任务需要多少时间（Estimate）</li></ul></li><li>开发（Development）<ul><li>分析需求（Analysis）</li><li>生成设计文档（Design Spec）</li><li>设计复审（Design Review），和同事审核设计文档</li><li>代码规范（Coding Standard），为目前的开发制定合适的规范</li><li>具体设计（Design）</li><li>具体编码（Coding）</li><li>代码复审（Code Review）</li><li>测试（Test），包括自我测试，修改代码，提交修改</li></ul></li><li>报告（Reporting）<ul><li>记录时间花费（Record Time Spent）</li><li>测试报告（Test Report）</li><li>计算工作量（Size Measurement）</li><li>事后总结（Postmortem）</li><li>提出过程改进计划（Process Improvement Plan）</li></ul></li></ul><p>示例：</p></li></ul><table><thead><tr><th>PSP2.1</th><th>Time (%) Senior Student</th><th>Time (%) SDE</th></tr></thead><tbody><tr><td>Planning</td><td>8</td><td>6</td></tr><tr><td>Estimate</td><td>8</td><td>6</td></tr><tr><td>Development</td><td>82</td><td>88</td></tr><tr><td>Analysis</td><td>6</td><td>10</td></tr><tr><td>Design Spec</td><td>5</td><td>6</td></tr><tr><td>Design Review</td><td>4</td><td>6</td></tr><tr><td>Coding Standard</td><td>3</td><td>3</td></tr><tr><td>Design</td><td>10</td><td>12</td></tr><tr><td>Coding</td><td>36</td><td>21</td></tr><tr><td>Code Review</td><td>7</td><td>9</td></tr><tr><td>Test</td><td>13</td><td>21</td></tr><tr><td>Reporting</td><td>9</td><td>6</td></tr><tr><td>Test Report</td><td>3</td><td>2</td></tr><tr><td>Size Measurement</td><td>2</td><td>1</td></tr><tr><td>Postmortem &amp; Process Improvement Plan</td><td>3</td><td>3</td></tr></tbody></table>]]></content>
      
      
        <tags>
            
            <tag> saad </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Stingy Sat</title>
      <link href="/algorithm/stingy-sat/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本博客作为《算法与设计》课程第 19 周的作业</li><li>题目类型：NP Complete</li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>STINGY SAT is the following problem: given a set of clauses (each a disjunction of literals) and an integer k, find a satisfying assignment in which at most k variables are true, if such an assignment exists. Prove that STINGY SAT is NP-complete.</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ul><li>给定一个 STINGY SAT 问题的解，可以在多项式时间内验证。遍历查看是否最多只有 k 个值为真即可。</li><li>对于一个 SAT 问题，将 k 赋值给其变量的总数，即可将其转换为 STINGY SAT 问题，所以其转化是可以在多项式时间内完成的。</li><li>若 STINGY SAT 有解，则对应的 SAT 问题一定也存在解，其本质相同。</li><li>若无解，则对应的 SAT 问题也是无解的。</li></ul><p>综上， SAT 问题可以归约到 STINGY SAT 问题，所以 STINGY SAT 问题是 NP Complete 的。</p>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Median of Two Sorted Arrays</title>
      <link href="/algorithm/median-of-two-sorted-arrays/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本博客作为《算法与设计》课程第 18 周的作业</li><li>题目来源：<a href="https://leetcode.com/problems/median-of-two-sorted-arrays" target="_blank" rel="external">LeetCode #4</a></li><li>题目类型：Divide and Conquer</li><li>编程语言：C++</li><li>运行结果：<img src="/algorithm/median-of-two-sorted-arrays/images/result.png" alt=""></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="/algorithm/median-of-two-sorted-arrays/images/description.png" alt=""></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>假设两个数组总共有 (m+n) 个元素，那么显然我们有用 O(m) 时间和 O(n) 空间的方法：用 Merge Sort 的思路排序，排序好的数组取出下标为 (m+n)/2 的元素就是我们需要的答案。</p><p>这个方法比较容易想到，但是时间复杂度是 O(m+n)，而题目要求的是 O(log(m+n))。所以还是想办法另辟蹊径！</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>我们可以发现，现在我们是不需要“排序”这么复杂的操作的，因为我们仅仅需要中位数。我们可以用一个计数器，记录当前已经找到第 m 大的元素了。同时我们使用两个指针 pA 和 pB，分别指向 A 和 B 数组的第一个元素。</p><p>使用类似于 Merge Sort 的原理：</p><ul><li>如果数组 A 当前元素小，那么 pA++，同时 m++。</li><li>如果数组 B 当前元素小，那么 pB++，同时 m++。</li></ul><p>最终当 m 等于 (m+n)/2 的时候，就找到所求元素了。</p><p>但是！时间复杂度还是跟方案一一样，还是得继续脑洞！</p><h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><p>将原问题转变成一个寻找第 k 小数的问题（假设两个原序列升序排列），这样中位数实际上是第 (m+n)/2 小的数。所以只要解决了第 k 小数的问题，原问题也得以解决。</p><p>首先假设数组 A 和 B 的元素个数都大于 k/2，我们比较 A[k/2-1] 和 B[k/2-1] 两个元素，这两个元素分别表示 A 的第 k/2 小的元素和 B 的第 k/2 小的元素。这两个元素比较共有三种情况：&gt;、&lt; 和 =。</p><p>如果 A[k/2-1] &lt; B[k/2-1]，这表示 A[0] 到 A[k/2-1] 的元素都在A和B合并之后的前 k 小的元素中。换句话说，A[k/2-1] 不可能大于两数组合并之后的第k小值，所以我们可以将其抛弃。</p><p>证明也很简单，可以采用反证法。假设 A[k/2-1] 大于合并之后的第k小值，我们不妨假定其为第 (k+1) 小值。由于 A[k/2-1] 小于 B[k/2-1]，所以 B[k/2-1] 至少是第 (k+2) 小值。但实际上，在 A 中至多存在 k/2-1 个元素小于 A[k/2-1]，B 中也至多存在 k/2-1 个元素小于 A[k/2-1]，所以小于 A[k/2-1] 的元素个数至多有 k/2+k/2-2，小于 k，这与 A[k/2-1] 是第 (k+1) 的数矛盾。</p><ul><li>当 A[k/2-1] &gt; B[k/2-1] 时，存在类似的结论。</li><li>当 A[k/2-1] = B[k/2-1] 时，我们已经找到了第 k 小的数，也即这个相等的元素，我们将其记为 m。由于在 A 和 B 中分别有 k/2-1 个元素小于 m，所以 m 即是第 k 小的数。</li></ul><p>这里可能有人会有疑问，如果 k 为奇数，则 m 不是中位数。这里是进行了理想化考虑，在实际代码中略有不同，是先求 k/2，然后利用 k-k/2 获得另一个数。</p><p>通过上面的分析，我们即可以采用递归的方式实现寻找第 k 小的数。此外我们还需要考虑几个边界条件：</p><ul><li>如果 A 或者 B 为空，则直接返回 B[k-1] 或者 A[k-1]</li><li>如果 k 为 1，我们只需要返回 A[0] 和 B[0] 中的较小值</li><li>如果 A[k/2-1] = B[k/2-1]，返回其中一个</li></ul><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = nums1.size();</div><div class="line">        <span class="keyword">int</span> m = nums2.size();</div><div class="line">        <span class="keyword">if</span>(n &gt; m)   <span class="comment">//保证数组1一定最短</span></div><div class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2,nums1);</div><div class="line">        <span class="keyword">int</span> L1,L2,R1,R2,c1,c2,lo = <span class="number">0</span>, hi = <span class="number">2</span>*n;  <span class="comment">//我们目前是虚拟加了'#'所以数组1是2*n长度</span></div><div class="line">        <span class="keyword">while</span>(lo &lt;= hi)   <span class="comment">//二分</span></div><div class="line">        &#123;</div><div class="line">            c1 = (lo+hi)/<span class="number">2</span>;  <span class="comment">//c1是二分的结果</span></div><div class="line">            c2 = m+n- c1;</div><div class="line">            L1 = (c1 == <span class="number">0</span>)?INT_MIN:nums1[(c1<span class="number">-1</span>)/<span class="number">2</span>];   <span class="comment">//map to original element</span></div><div class="line">            R1 = (c1 == <span class="number">2</span>*n)?INT_MAX:nums1[c1/<span class="number">2</span>];</div><div class="line">            L2 = (c2 == <span class="number">0</span>)?INT_MIN:nums2[(c2<span class="number">-1</span>)/<span class="number">2</span>];</div><div class="line">            R2 = (c2 == <span class="number">2</span>*m)?INT_MAX:nums2[c2/<span class="number">2</span>];</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(L1 &gt; R2)</div><div class="line">                hi = c1<span class="number">-1</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(L2 &gt; R1)</div><div class="line">                lo = c1+<span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (max(L1,L2)+ min(R1,R2))/<span class="number">2.0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Partition Equal Subset Sum</title>
      <link href="/algorithm/partition-equal-subset-sum/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本博客作为《算法与设计》课程第 17 周的作业</li><li>题目来源：<a href="https://leetcode.com/problems/partition-equal-subset-sum" target="_blank" rel="external">LeetCode #416</a></li><li>题目类型：Dynamic Programming</li><li>编程语言：Java</li><li>运行结果：<img src="/algorithm/partition-equal-subset-sum/images/result.png" alt=""></li><li>参考：<a href="https://www.cnblogs.com/shinning/p/6027743.html" target="_blank" rel="external">0-1背包问题</a></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="/algorithm/partition-equal-subset-sum/images/description.png" alt=""></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>这道题理解起来非常简单，穷举一下数组的子集合，看是否存在一个子集合的加和刚好是原数组加和的一半即可。但穷举…肯定会超时，实际做起来需要动用到动态规划！</p><p>分析一下这个问题，其实跟 01-背包问题很是类似。区别其实只在于：01-背包问题中的变量有两个：价值 v 和重量 w。而这道题中，变量只有一个：加和 s。用数组 dp[i][j] 来表示总和不超过 j 时的前 i 个元素的最大和。可得出状态转移方程为：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[i][j] = Math.max(dp[i - 1][j - nums[i]] + nums[i], dp[i - 1][j])</div></pre></td></tr></table></figure></p><p>在本题情况中，dp[i][j] 只与上一层循环得到的dp[i - 1][x] 有关，故只需要一维数组，每次更新数组值即可。</p><p>假设 dp[s] 表示在不超过 s 的情况下，子集合最大的加和。用题目中的例子 [1, 5, 11, 5] 来解释就是：</p><ul><li>dp[1] = 1</li><li>dp[5] = 5</li><li>dp[9] = 6（由 1 + 5 得到）</li><li>dp[10] = 10</li><li>dp[11] = 11（由 1 + 5 + 5 得到）</li><li>dp[22] = 22（所有元素相加得到）<br>值得注意的是，总有：dp[i] &lt;= i 成立。</li></ul><p>继续分析，假设输入的数组是 nums，我们首先将其求和，得到 sum。</p><p>如果 sum 是基数，肯定不存在满足条件的子数组，直接返回 false 即可。</p><p>如果 sum 是偶数，则才有可能存在满足条件的子数组。那如何引入 01-背包的思想呢？如果我们能找到刚好和为 sum / 2 的子数组，那么剩下没选到的元素之和肯定也是 sum / 2。因此就等价于我们在 01-背包问题中找到恰好满足：dp[sum] = sum 的情况，这也就意味着这时的子数组刚好能凑到原数组的一半。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            sum += nums[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>; </div><div class="line">        sum /= <span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</div><div class="line">            <span class="comment">// j 要从大到小遍历，避免在更新数组的过程中使用到当次更新的数组元素</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = sum; j &gt;= nums[i]; j--) &#123;</div><div class="line">                dp[j] = Math.max(dp[j - nums[i]] + nums[i], dp[j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[sum] == sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Minimum Path Sum (via Floyd)</title>
      <link href="/algorithm/minimum-path-sum-via-floyd/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本博客作为《算法与设计》课程第 16 周的作业</li><li>题目来源：<a href="https://leetcode.com/problems/minimum-path-sum" target="_blank" rel="external">LeetCode #64</a></li><li>题目类型：Dynamic Programming</li><li>编程语言：C</li><li>运行结果：<img src="/algorithm/minimum-path-sum-via-floyd/images/result.png" alt=""></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="/algorithm/minimum-path-sum-via-floyd/images/description.png" alt=""></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>最短路径问题其实是一个很常见的算法问题，路径是否为有向对应的解法也是不同的。</p><ul><li>对于有向路径，可以通过 dist(u, v) = dist(u, k) + length(k, v) 的动态规划方法来求解</li><li>对于无向路径，可以通过：<ul><li>dist(u, v) = min{ dist(u, v), dist(u, k) + dist(k, v)} 的动态规划方法来求解（Floyd 算法）</li><li>Dijkstra 的贪心算法来求解，详见：<a href="https://painterdrown.github.io/algorithm/minimum-path-sum-via-dijkstra" target="_blank" rel="external">Minimum Path Sum (via Dijkstra)</a></li></ul></li></ul><p>这次要讨论的解决方法是 Floyd 算法：Floyd 算法是一个经典的动态规划算法。从任意节点 u 到任意节点 v 的最短路径不外乎 2 种可能：</p><ul><li>直接从 u 到 v</li><li>从 u 经过某个中间节点 k 再到 v</li></ul><p>所以，我们假设 dist(u, v) 为节点 u 到节点 v 的最短路径的距离。对于每一个其他的中间节点 k，我们检查：<br><br><code>dist(u, v) &gt; dist(u, k) + dist(k, v)</code><br><br>是否成立。如果成立，证明从 u 到 k 再到 v 的路径比 u 直接到 v 的路径短，我们便更新：<br><br><code>dist(u, v) = dist(u, k) + dist(k, v)</code><br><br>这样一来，当我们遍历完所有节点k，dist(u, v) 便是 u 到 v 的最短路径的距离。</p><p>但是注意一下题目到描述：</p><blockquote><p>You can only move either down or right at any point in time.</p></blockquote><p>因此，可以将本题目视为一个有向的最短路径题目，假设题目中输入的矩阵是 matrix。dist(i, j) 表示从 matrix[0, 0] 到达 matrix[i, j] 到最短路径之和，则有：</p><ul><li>dist(i, j) = dist(i, j - 1) + matrix[i, j]，当 dist[i, j - 1] 较小时</li><li>dist(i, j) = dist(i - 1, j) + matrix[i, j]，当 dist[i - 1, j] 较小时</li></ul><p>最终，dist(m - 1, n - 1) 为所求最短路径之和（m, n 分别代表 matrix 的行数和列数）。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 非递归版本</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> a &lt; b ? a : b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>** matrix, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</div><div class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) matrix[<span class="number">0</span>][j] = matrix[<span class="number">0</span>][j<span class="number">-1</span>] + matrix[<span class="number">0</span>][j];</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) matrix[i][<span class="number">0</span>] = matrix[i<span class="number">-1</span>][<span class="number">0</span>] + matrix[i][<span class="number">0</span>];</div><div class="line">            <span class="keyword">else</span> matrix[i][j] = min(matrix[i][j<span class="number">-1</span>], matrix[i<span class="number">-1</span>][j]) + matrix[i][j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> matrix[m<span class="number">-1</span>][n<span class="number">-1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 递归版本</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> a &lt; b ? a : b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span>** matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">return</span> matrix[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> dist(matrix, <span class="number">0</span>, j - <span class="number">1</span>) + matrix[<span class="number">0</span>][j];</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="keyword">return</span> dist(matrix, i - <span class="number">1</span>, <span class="number">0</span>) + matrix[i][<span class="number">0</span>];</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> min(dist(matrix, i - <span class="number">1</span>, j), dist(matrix, i, j - <span class="number">1</span>)) + matrix[i][j];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>** matrix, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> dist(matrix, m - <span class="number">1</span>, n - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Minimum Path Sum (via Dijkstra)</title>
      <link href="/algorithm/minimum-path-sum-via-dijkstra/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本博客作为《算法与设计》课程第 15 周的作业</li><li>题目来源：<a href="https://leetcode.com/problems/minimum-path-sum" target="_blank" rel="external">LeetCode #64</a></li><li>题目类型：Greedy</li><li>编程语言：C++</li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="/algorithm/minimum-path-sum-via-dijkstra/images/description.png" alt=""></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>Dijkstra 算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。算法的基本思想是贪心算法，从源节点开始，不断地以最小代价向其他未到达的节点拓展，直到覆盖目标节点为止。</p><p>在这个问题中，假设输入的矩阵是 matrix（m 行 n 列），算法的具体过程如下：</p><ol><li>初始化：<ul><li>集合 A = { v0 }。v0 起点，A 代表代表已经到达的节点</li><li>bool last[m][n] 用于记录达到该点的上一个点，true 表示上方的点，false 表示左边的点</li></ul></li><li>从 A 中任意点开始走一步，假设最近到达的节点为 v，则将 v 加到集合 A 中</li><li>重复步骤 2，直到终点也在 A 中</li><li>最后根据 last 矩阵从终点追溯到起点，即可获取该最短路径，将路径上的值求和即为所求最短路径之和</li></ol><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>这次算法比较简单因此不再赘述，参考下面的数据结构与上面的 4 个步骤即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> row;</div><div class="line">    <span class="keyword">int</span> col;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 用于记录已经达到的 Node</span></div><div class="line"><span class="built_in">vector</span>&lt;struct Node&gt; A;</div><div class="line"></div><div class="line"><span class="comment">// 用于记录达到该 Node 的上一个 Node 的相对方向</span></div><div class="line"><span class="keyword">bool</span> **last = <span class="keyword">new</span> <span class="keyword">bool</span>*[m];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</div><div class="line">  last[i] = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Best Time to Buy and Sell Stock (via DP)</title>
      <link href="/algorithm/best-time-to-buy-and-sell-stock-via-dp/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本博客作为《算法与设计》课程第 14 周的作业</li><li>题目来源：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="external">LeetCode #121</a></li><li>题目类型：Dynamic Programming</li><li>编程语言：C++</li><li>运行结果：<img src="/algorithm/best-time-to-buy-and-sell-stock-via-dp/images/result.png" alt=""></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="/algorithm/best-time-to-buy-and-sell-stock-via-dp/images/description.png" alt=""></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>乍一看，这道题的做法应该是找出最大的 prices[j] - prices[i]，其中 i &lt; j。<br>最容易想到的做法就是穷举，但是时间复杂度看不下去🙈。</p><p>转化一下思路，如果我们由 prices 得到相邻两台的股票差价数组 differences。<br>则原问题就转化为求 differences 的最大连续子数组问题了！</p><p>最大子数组问题有比较多的解法：</p><ul><li><p>穷举</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// C</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* differences, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> result = <span class="number">0</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</div><div class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k) &#123;</div><div class="line">        sum += differences[k];</div><div class="line">      &#125;</div><div class="line">      result = max(result, sum);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>分治</p><blockquote><p>参考：<a href="https://painterdrown.github.io/algorithm/best-time-to-buy-and-sell-stock-via-dc" target="_blank" rel="external">Best Time to Buy and Sell Stock (via DC)</a></p></blockquote></li><li>动态规划</li></ul><p>这里要介绍的是动态规划：我们用 c[i] 来表示前 i 个元素组成的子数组的最大和，则有：<br><br><code>c[i] = max(c[i - 1] + differences[i], differences[i])</code><br><br>注意，上面说的子数组是肯定包括 differences[i]，但是最大和不一定包括 differences[i]。<br>因此，最大和应该是：max{ c[0], …, c[n - 1] }，其中 n 是数组 differences 的长度。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// C++</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> a &gt; b ? a : b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> n = (<span class="keyword">int</span>)prices.size();</div><div class="line">      <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">      <span class="keyword">int</span> *c = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">      c[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</div><div class="line">          <span class="keyword">int</span> difference = prices[i] - prices[i - <span class="number">1</span>];</div><div class="line">          c[i] = max(c[i - <span class="number">1</span>] + difference, difference);</div><div class="line">          <span class="keyword">if</span> (c[i] &lt; <span class="number">0</span>) c[i] = <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">          result = max(result, c[i]);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java</span></div><div class="line"></div><div class="line"><span class="comment">// 改进版本 (Kadane 算法)</span></div><div class="line"><span class="comment">// 用 maxEndingHere 表示以当前为结束的子数组的最大和，以替代数组 c</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> maxEndingHere = <span class="number">0</span>, maxSoFar = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</div><div class="line">    maxEndingHere += prices[i] - prices[i - <span class="number">1</span>];</div><div class="line">    maxEndingHere = Math.max(maxEndingHere, <span class="number">0</span>);</div><div class="line">    maxSoFar = Math.max(maxEndingHere, maxSoFar);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> maxSoFar;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Best Time to Buy and Sell Stock (via DC)</title>
      <link href="/algorithm/best-time-to-buy-and-sell-stock-via-dc/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本博客作为《算法与设计》课程第 13 周的作业</li><li>题目来源：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="external">LeetCode #121</a></li><li>题目类型：Divide and Conquer</li><li>编程语言：C++</li><li>运行结果：<img src="/algorithm/best-time-to-buy-and-sell-stock-via-dc/images/result.png" alt=""></li><li>参考：<a href="http://www.cnblogs.com/en-heng/p/3970231.html" target="_blank" rel="external">连续子数组最大和</a></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="/algorithm/best-time-to-buy-and-sell-stock-via-dc/images/description.png" alt=""></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><blockquote><p>参考：<a href="https://painterdrown.github.io/algorithm/best-time-to-buy-and-sell-stock-via-dp" target="_blank" rel="external">Best Time to Buy and Sell Stock (via DP)</a></p></blockquote><p>参考上面博客中“问题分析”，先将问题转化为最大连续子数组的问题：<br><br><code>prices[n] -&gt; differences[n - 1]</code></p><p>对于 differences 数组，想要求它的最大连续子数组，运用分治的思想，将 differences 划分为两个相等长度的子数组a, b：</p><p><img src="/algorithm/best-time-to-buy-and-sell-stock-via-dc/images/ab.png" alt=""></p><p>那么最大连续子数组不外乎下面三种情况：</p><ul><li>原数组的最大连续子数组就是 a 的最大连续子数组 ma<br><br><img src="/algorithm/best-time-to-buy-and-sell-stock-via-dc/images/ma.png" alt=""></li><li>原数组的最大连续子数组就是 b 的最大连续子数组 mb<br><br><img src="/algorithm/best-time-to-buy-and-sell-stock-via-dc/images/mb.png" alt=""></li><li>原数组的最大连续子数组同时在 a, b 中间，即下图中的 mc<br><br><img src="/algorithm/best-time-to-buy-and-sell-stock-via-dc/images/mc.png" alt=""></li></ul><p>即 result = max(sum(ma), sum(mb), sum(mc))。<br>其中，sum(mc) = 从中间元素开始往左累加的最大值 + 从中间元素往右累加的最大值。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 相比于动态规划的解法 O(n)，这里的算法复杂度是 O(nlogn)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; differences;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = a &gt; b ? a : b;</div><div class="line">        <span class="keyword">return</span> temp &gt; c ? temp : c;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> u)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (l &gt; u) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (l == u) <span class="keyword">return</span> max2(<span class="number">0</span>, differences[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">int</span> m = (l + u) / <span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> sum;</div><div class="line">        <span class="keyword">int</span> lmax = <span class="number">0</span>, rmax = <span class="number">0</span>;</div><div class="line">        sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= l; --i) &#123;</div><div class="line">            sum += differences[i];</div><div class="line">            lmax = max2(lmax, sum);</div><div class="line">        &#125;</div><div class="line">        sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt;= u; ++i) &#123;</div><div class="line">            sum += differences[i];</div><div class="line">            rmax = max2(rmax, sum);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max3(dc(l, m), dc(m + <span class="number">1</span>, u), lmax + rmax);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)prices.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</div><div class="line">            differences.push_back(prices[i] - prices[i - <span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 注意这里是 n - 2，因为 differences 比 prices 少一个元素</span></div><div class="line">        <span class="keyword">return</span> dc(<span class="number">0</span>, n - <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Regular Expression Matching (via Recursion)</title>
      <link href="/algorithm/regular-expression-matching-via-recursion/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本博客作为《算法与设计》课程第 12 周的作业</li><li>题目来源：<a href="https://leetcode.com/problems/regular-expression-matching" target="_blank" rel="external">LeetCode #10</a></li><li>题目类型：Recursion</li><li>编程语言：C++</li><li>运行结果：<img src="/algorithm/regular-expression-matching-via-recursion/images/result.png" alt=""></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="/algorithm/regular-expression-matching-via-recursion/images/description.png" alt=""></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>用递归来解，大概思路如下：</p><ul><li>若 p 为空，若 s 也为空，返回 true，反之返回 false</li><li>若 p 的长度为1，若 s 长度也为1，且相同或是 p 为’.’则返回 true，反之返回 false</li><li>若 p 的第二个字符不为 *，若此时 s 为空返回 false，否则判断首字符是否匹配，且从各自的第二个字符开始调用递归函数匹配</li><li>若p的第二个字符为 *，若 s 不为空且字符匹配，调用递归函数匹配 s 和去掉前两个字符的 p，若匹配返回 true，否则 s 去掉首字母</li><li>返回调用递归函数匹配 s 和去掉前两个字符的 p 的结果</li></ul><p>我们先来判断 p 是否为空，若为空则根据 s 的为空的情况返回结果。当 p 的第二个字符为 <em> 号时，由于 </em> 号前面的字符的个数可以任意，可以为 0，那么我们先用递归来调用为 0 的情况，就是直接把这两个字符去掉再比较，或者当 s 不为空，且第一个字符和 p 的第一个字符相同时，我们再对去掉首字符的 s 和 p 调用递归，注意 p 不能去掉首字符，因为 <em> 号前面的字符可以有无限个；如果第二个字符不为 </em> 号，那么我们就老老实实的比较第一个字符，然后对后面的字符串调用递归，</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 解法一</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (p.empty()) <span class="keyword">return</span> s.empty();</div><div class="line">        <span class="keyword">if</span> (p.size() == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> (s.size() == <span class="number">1</span> &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (p[<span class="number">1</span>] != <span class="string">'*'</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            <span class="keyword">return</span> (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>) &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>)) &#123;</div><div class="line">            <span class="keyword">if</span> (isMatch(s, p.substr(<span class="number">2</span>))) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            s = s.substr(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> isMatch(s, p.substr(<span class="number">2</span>));</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 解法二</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (p.empty()) <span class="keyword">return</span> s.empty();</div><div class="line">        <span class="keyword">if</span> (p.size() &gt; <span class="number">1</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> isMatch(s, p.substr(<span class="number">2</span>)) || (!s.empty() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>) &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> !s.empty() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>) &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Regular Expression Matching (via DP)</title>
      <link href="/algorithm/regular-expression-matching-via-dp/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本博客作为《算法与设计》课程第 11 周的作业</li><li>题目来源：<a href="https://leetcode.com/problems/regular-expression-matching" target="_blank" rel="external">LeetCode #10</a></li><li>题目类型：Dynamic Programming</li><li>编程语言：C++</li><li>运行结果：<img src="/algorithm/regular-expression-matching-via-dp/images/result.png" alt=""></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="/algorithm/regular-expression-matching-via-dp/images/description.png" alt=""></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><blockquote><p>参考：<a href="https://painterdrown.github.com/algorithm/median-of-two-sorted-arrays/" target="_blank" rel="external">Regular Expression Matching (via Recursion)</a></p></blockquote><p>我们也可以用 DP 来解，定义一个二维的 dp 数组，其中 dp[i][j] 表示 s[0,i) 和 p[0,j) 是否 match，然后有下面三种情况：</p><ul><li>P[i][j] = P[i - 1][j - 1], if p[j - 1] != ‘*’ &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == ‘.’)</li><li>P[i][j] = P[i][j - 2], if p[j - 1] == ‘*’ and the pattern repeats for 0 times</li><li>P[i][j] = P[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == ‘.’), if p[j - 1] == ‘*’ and the pattern repeats for at least 1 times</li></ul><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> m = s.size(), n = p.size();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</div><div class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</div><div class="line">                <span class="keyword">if</span> (j &gt; <span class="number">1</span> &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</div><div class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>] || (i &gt; <span class="number">0</span> &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] || p[j - <span class="number">2</span>] == <span class="string">'.'</span>) &amp;&amp; dp[i - <span class="number">1</span>][j]);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    dp[i][j] = i &gt; <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">'.'</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[m][n];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3Sum Closest</title>
      <link href="/algorithm/3sum-closest/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本博客作为《算法与设计》课程第 10 周的作业</li><li>题目来源：<a href="https://leetcode.com/problems/3sum-closest" target="_blank" rel="external">LeetCode #16</a></li><li>题目类型：Divide and Conquer</li><li>编程语言：C++</li><li>运行结果：<img src="/algorithm/3sum-closest/images/result.png" alt=""></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="/algorithm/3sum-closest/images/description.png" alt=""></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><blockquote><p>参考：<a href="https://painterdrown.github.com/algorithm/3sum" target="_blank" rel="external">3Sum</a></p></blockquote><p>这道题让我们求最接近给定值的三数之和，是在之前那道 3Sum 三数之和的基础上又增加了些许难度，那么这道题让我们返回这个最接近于给定值的值，即我们要保证当前三数和跟给定值之间的差的绝对值最小，所以我们需要定义一个变量 diff 用来记录差的绝对值，然后我们还是要先将数组排个序，然后开始遍历数组，思路跟那道三数之和很相似，都是先确定一个数，然后用两个指针 left 和 right 来滑动寻找另外两个数，每确定两个数，我们求出此三数之和，然后算和给定值的差的绝对值存在 newDiff 中，然后和 diff 比较并更新 diff 和结果 closest 即可。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> closest = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</div><div class="line">        <span class="keyword">int</span> diff = <span class="built_in">abs</span>(closest - target);</div><div class="line">        sort(nums.begin(), nums.end());</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">2</span>; ++i) &#123;</div><div class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>, right = nums.size() - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">                <span class="keyword">int</span> sum = nums[i] + nums[left] + nums[right];</div><div class="line">                <span class="keyword">int</span> newDiff = <span class="built_in">abs</span>(sum - target);</div><div class="line">                <span class="keyword">if</span> (diff &gt; newDiff) &#123;</div><div class="line">                    diff = newDiff;</div><div class="line">                    closest = sum;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (sum &lt; target) ++left;</div><div class="line">                <span class="keyword">else</span> --right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> closest;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3Sum</title>
      <link href="/algorithm/3sum/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本博客作为《算法与设计》课程第 9 周的作业</li><li>题目来源：<a href="https://leetcode.com/problems/3sum" target="_blank" rel="external">LeetCode #15</a></li><li>题目类型：Divide and Conquer</li><li>编程语言：C++</li><li>运行结果：<img src="/algorithm/3sum/images/result.png" alt=""></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="/algorithm/3sum/images/description.png" alt=""></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>假设 3sum 问题的目标是 target。每次从数组中选出一个数 k，从剩下的数中求目标等于 target-k 的 2sum 问题。这里需要注意的是有个小的 trick：当我们从数组中选出第 i 数时，我们只需要求数值中从第 i+1 个到最后一个范围内字数组的 2sum 问题。假设数组为 A[]，总共有 n 个元素 A1，A2….An。很显然，当选出 A1 时，我们在子数组 [A2~An] 中求目标位 target-A1 的 2sum 问题，我们要证明的是当选出 A2 时，我们只需要在子数组 [A3~An] 中计算目标位 target-A2 的 2sum 问题，而不是在子数组 [A1,A3~An] 中，证明如下：</p><p>假设在子数组 [A1, A3~An] 目标位 target-A2 的 2sum 问题中，存在 A1+m = target-A2（m 为 A3~An 中的某个数），即 A2+m = target-A1，这刚好是“对于子数组 [A2~An]，目标为 target-A1 的 2sum 问题”的一个解。即我们相当于对满足 3sum 的三个数 A1+A2+m = target 重复计算了。因此为了避免重复计算，在子数组 [A1，A3~An] 中，可以把 A1 去掉，再来计算目标是 target-A2 的 2sum 问题。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="keyword">int</span> n = nums.size();</div><div class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</div><div class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>)</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        sort(nums.begin(), nums.end());</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> ||  (i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i - <span class="number">1</span>]))</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> left = i + <span class="number">1</span>, right = n - <span class="number">1</span>;</div><div class="line">                <span class="keyword">int</span> sum = <span class="number">0</span> - nums[i];</div><div class="line">                <span class="keyword">while</span>(left &lt; right)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(nums[left] + nums[right] == sum)</div><div class="line">                    &#123;</div><div class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</div><div class="line">                        vi.push_back(nums[i]);</div><div class="line">                        vi.push_back(nums[left]);</div><div class="line">                        vi.push_back(nums[right]);</div><div class="line">                        res.push_back(vi);</div><div class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])</div><div class="line">                            left++;</div><div class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])</div><div class="line">                            right--;</div><div class="line">                        left++;</div><div class="line">                        right--;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(nums[left] + nums[right] &lt; sum)</div><div class="line">                        left++;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        right--;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Merge k Sorted Lists</title>
      <link href="/algorithm/merge-k-sorted-lists/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本博客作为《算法与设计》课程第 8 周的作业</li><li>题目来源：<a href="https://leetcode.com/problems/merge-k-sorted-lists" target="_blank" rel="external">LeetCode #23</a></li><li>题目类型：Divide and Conquer</li><li>编程语言：C++</li><li>运行结果：<img src="/algorithm/merge-k-sorted-lists/images/result.png" alt=""></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><blockquote><p>参考：<a href="https://painterdrown.github.com/algorithm/merge-two-sorted-lists" target="_blank" rel="external">Merge Two Sorted Lists</a></p></blockquote><p>这道题让我们合并 k 个有序链表，参考 Merge Two Sorted Lists 混合插入有序链表，是混合插入两个有序链表。这道题增加了难度，变成合并 k 个有序链表了，但是不管合并几个，基本还是要两两合并。那么我们首先考虑的方法是能不能利用之前那道题的解法来解答此题。</p><p>答案是肯定的，但是需要修改，怎么修改呢，最先想到的就是两两合并，就是前两个先合并，合并好了再跟第三个，然后第四个直到第 k 个。这样的思路是对的，但是效率不高，没法通过OJ，所以我们只能换一种思路，这里就需要用到分治法。</p><p>简单来说就是不停的对半划分，比如k个链表先划分为合并两个 k/2 个链表的任务，再不停的往下划分，直到划分成只有一个或两个链表的任务，开始合并。举个例子来说比如合并 6 个链表，那么按照分治法，我们首先分别合并 1 和 4, 2 和 5, 3 和 6。这样下一次只需合并 3 个链表，我们再合并 1 和 3，最后和 2 合并就可以了。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (lists.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">int</span> n = lists.size();</div><div class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> k = (n + <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</div><div class="line">                lists[i] = mergeTwoLists(lists[i], lists[i + k]);</div><div class="line">            &#125;</div><div class="line">            n = k;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</div><div class="line">        ListNode *head = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</div><div class="line">        ListNode *cur = head;</div><div class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</div><div class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</div><div class="line">                cur-&gt;next = l1;</div><div class="line">                l1 = l1-&gt;next;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                cur-&gt;next = l2;</div><div class="line">                l2 = l2-&gt;next;</div><div class="line">            &#125;</div><div class="line">            cur = cur-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (l1) cur-&gt;next = l1;</div><div class="line">        <span class="keyword">if</span> (l2) cur-&gt;next = l2;</div><div class="line">        <span class="keyword">return</span> head-&gt;next;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Merge Two Sorted Lists</title>
      <link href="/algorithm/merge-two-sorted-lists/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本博客作为《算法与设计》课程第 7 周的作业</li><li>题目来源：<a href="https://leetcode.com/problems/merge-two-sorted-lists" target="_blank" rel="external">LeetCode #21</a></li><li>题目类型：Divide and Conquer</li><li>编程语言：C++</li><li>运行结果：<img src="/algorithm/merge-two-sorted-lists/images/result.png" alt=""></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>其实就是归并排序的思想：新建一个链表，然后比较两个链表中的元素值，把较小的那个链到新链表中，由于两个输入链表的长度可能不同，所以最终会有一个链表先完成插入所有元素，则直接另一个未完成的链表直接链入新链表的末尾。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</div><div class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), *cur = dummy;</div><div class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</div><div class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</div><div class="line">                cur-&gt;next = l1;</div><div class="line">                l1 = l1-&gt;next;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                cur-&gt;next = l2;</div><div class="line">                l2 = l2-&gt;next;</div><div class="line">            &#125;</div><div class="line">            cur = cur-&gt;next;</div><div class="line">        &#125;</div><div class="line">        cur-&gt;next = l1 ? l1 : l2;</div><div class="line">        <span class="keyword">return</span> dummy-&gt;next;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Task Scheduler</title>
      <link href="/algorithm/task-scheduler/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本博客作为《算法与设计》课程第 6 周的作业</li><li>题目来源：<a href="https://leetcode.com/problems/task-scheduler" target="_blank" rel="external">LeetCode #621</a></li><li>题目类型：Greedy</li><li>编程语言：C++</li><li>运行结果：<img src="/algorithm/task-scheduler/images/result.png" alt=""></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="/algorithm/task-scheduler/images/description.png" alt=""></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>这道题让我们安排 CPU 的任务，规定在两个相同任务之间至少隔 n 个时间点。由于题目中规定了两个相同任务之间至少隔 n 个时间点，那么我们首先应该处理的出现次数最多的那个任务，先确定好这些高频任务，然后再来安排那些低频任务。如果任务F的出现频率最高，为 k 次，那么我们用 n 个空位将每两个 F 分隔开，然后我们按顺序加入其他低频的任务，来看一个例子：</p><p><code>AAAABBBEEFFGG 3</code></p><p>我们发现任务 A 出现了 4 次，频率最高，于是我们在每个A中间加入三个空位，如下：</p><p><code>A---A---A---A  (初始)&lt;br/&gt;AB--AB--AB--A  (加入 B)&lt;br/&gt;ABE-ABE-AB--A  (加入 E)&lt;br/&gt;ABEFABE-ABF-A  (加入 F，每次尽可能填满或者是均匀填充)&lt;br/&gt;ABEFABEGABFGA  (加入 G)</code></p><p>再来看一个例子：</p><p><code>ACCCEEE 2</code></p><p>我们发现任务 C 和 E 都出现了三次，那么我们就将 CE 看作一个整体，在中间加入一个位置即可：</p><p><code>CE-CE-CE  (初始)&lt;br/&gt;CEACE-CE  (加入 A)</code></p><p>注意最后面那个 idle 不能省略，不然就不满足相同两个任务之间要隔2个时间点了。</p><p>我们仔细观察上面两个例子可以发现，都分成了 (mx-1) 块，再加上最后面的字母，其中 mx 为最大出现次数。</p><p>例子 1 中，A 出现了4次，所以有 A— 模块出现了 3 次，再加上最后的 A，每个模块的长度为 4。</p><p>例子 2 中，CE- 出现了 2 次，再加上最后的 CE，每个模块长度为 3。</p><p>我们可以发现，模块的次数为任务最大次数减 1，模块的长度为 n+1，最后加上的字母个数为出现次数最多的任务，可能有多个并列。这样三个部分都搞清楚了，写起来就不难了，我们统计每个大写字母出现的次数，然后排序，这样出现次数最多的字母就到了末尾，然后我们向前遍历，找出出现次数一样多的任务个数，就可以迅速求出总时间长了。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; tasks, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> task : tasks) &#123;</div><div class="line">            ++cnt[task - <span class="string">'A'</span>];</div><div class="line">        &#125;</div><div class="line">        sort(cnt.begin(), cnt.end());</div><div class="line">        <span class="keyword">int</span> i = <span class="number">25</span>, mx = cnt[<span class="number">25</span>], len = tasks.size();</div><div class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; cnt[i] == mx) --i;</div><div class="line">        <span class="keyword">return</span> max(len, (mx - <span class="number">1</span>) * (n + <span class="number">1</span>) + <span class="number">25</span> - i);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Remove Invalid Parentheses</title>
      <link href="/algorithm/remove-invalid-parentheses/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本博客作为《算法与设计》课程第 5 周的作业</li><li>题目来源：<a href="https://leetcode.com/problems/remove-invalid-parentheses" target="_blank" rel="external">LeetCode #301</a></li><li>题目类型：DFS</li><li>编程语言：C++</li><li>运行结果：<img src="/algorithm/remove-invalid-parentheses/images/result.png" alt=""></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="/algorithm/remove-invalid-parentheses/images/description.png" alt=""></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>对于括号匹配的问题其实并不陌生，用 stack 遇见左括号就进栈，遇见右括号就出栈即可，或者我们可以用更简单的——用一个 count 模拟栈，遇见左括号 ++count，遇见右括号就 -–count。因为只有 ( 和 ) 我们先对 ) 进行处理，至于 (，我们只需要倒着再做一次即可。</p><p>注意：在循环当中当且仅当我们找到一个多余的 ) 时，count &lt; 0（此处也保证了题目要求的最少量）。此时我们需要对当前的子串进行处理，即移除其中某个 )，问题是，哪一个呢？实际上，我们只需要移除任意一个即可。例子：</p><p><code>0 1 2 3 4 5 6&lt;br/&gt;( ) ( ) ) ( )</code></p><p>我们找到第 4 个括号时，发现需要移除一个 )，此时我们可以移除 s[1], s[3] 或者 s[4]，但又要注意，当有一连串 ) 排列在一起时，我们移除其中任意一个得到的答案是相同的。如移除 s[3] 或者 s[4]，我们都得到 ( ) ( ) ( )，因此我们默认规定移除一连串 ) 中的第一个 )。</p><p>当进行完以上这些步骤之后，当前子串已经是合法的了，剩下的我们只需要递归调用（类似 DFS）对后面的进行处理即可。再在返回之前检测是否左右括号都进行了处理，若都进行了处理，就是正确答案。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">char</span> pa[<span class="number">2</span>] = &#123;<span class="string">'('</span> , <span class="string">')'</span>&#125; ; <span class="comment">//检测右括号是否多余</span></div><div class="line">    <span class="keyword">char</span> pa_re[<span class="number">2</span>] = &#123;<span class="string">')'</span> , <span class="string">'('</span>&#125; ; <span class="comment">//检测左括号是否多余</span></div><div class="line"></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; removeInvalidParentheses(<span class="built_in">string</span> s) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans ;</div><div class="line">        _remove(s , ans , <span class="number">0</span> , <span class="number">0</span> , pa) ;</div><div class="line">        <span class="keyword">return</span> ans ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> _remove(<span class="built_in">string</span> s , <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;ans , <span class="keyword">int</span> last_i , <span class="keyword">int</span> last_j , <span class="keyword">char</span> pa[])&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = last_i , count = <span class="number">0</span> ; i &lt; s.size() ; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(s[i] == pa[<span class="number">0</span>]) ++count ;</div><div class="line">            <span class="keyword">if</span>(s[i] == pa[<span class="number">1</span>]) --count ;</div><div class="line">            <span class="comment">//直到我们找到有且仅有产生一个括号多余的情况</span></div><div class="line">            <span class="keyword">if</span>(count &gt;= <span class="number">0</span>) <span class="keyword">continue</span> ;</div><div class="line">            <span class="comment">//前面的任意一个括号都可以去掉，如果有多个连续，则默认去掉第一个</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = last_j ; j &lt;= i ; ++j)</div><div class="line">                <span class="keyword">if</span>(s[j] == pa[<span class="number">1</span>] &amp;&amp; (j == last_j || s[j - <span class="number">1</span>] != pa[<span class="number">1</span>]) )&#123;</div><div class="line">                    <span class="built_in">string</span> newStr = s.substr(<span class="number">0</span>,j) + s.substr(j+<span class="number">1</span>) ;</div><div class="line">                    _remove(newStr , ans , i , j , pa) ;</div><div class="line">                &#125;</div><div class="line">            <span class="keyword">return</span> ;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//倒转字符串</span></div><div class="line">        <span class="built_in">string</span> reversed_str ;</div><div class="line">        reversed_str.clear() ;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size() - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; --i)</div><div class="line">            reversed_str.push_back(s[i]) ;</div><div class="line"></div><div class="line">        <span class="comment">//确认我们是否已经检测过左括号，如果已经检测过，则可以放入答案中，如果还没有检测则检测左括号</span></div><div class="line">        <span class="keyword">if</span>(pa[<span class="number">0</span>] == <span class="string">'('</span>)&#123;</div><div class="line">            <span class="comment">//说明还没检测过</span></div><div class="line">            _remove(reversed_str , ans , <span class="number">0</span> , <span class="number">0</span> , pa_re) ;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="comment">//已经检测过</span></div><div class="line">            ans.push_back(reversed_str) ;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Minimum Height Trees</title>
      <link href="/algorithm/minimum-height-trees/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本博客作为《算法与设计》课程第 4 周的作业</li><li>题目来源：<a href="https://leetcode.com/problems/minimum-height-trees" target="_blank" rel="external">LeetCode #310</a></li><li>题目类型：BFS</li><li>编程语言：Java</li><li>运行结果：<img src="/algorithm/minimum-height-trees/images/result.png" alt=""></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="/algorithm/minimum-height-trees/images/description.png" alt=""></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>直觉就是使用 BFS 来解，每次放入只有一个 edge 的 node（现在的 leaf）。然后直到只剩最上面一层。注意考虑单独的 node（和别的 node 不相连）。比如: [[1,2], [2,3]], n = 6 这种情况，就有 [0, 4, 5] 三个点都不和别的 node 相连。还有 [], n = 2 的时候就要返回 [0, 1]。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</div><div class="line">        <span class="comment">// adjacent set</span></div><div class="line">        Set&lt;Integer&gt;[] set = <span class="keyword">new</span> HashSet[n];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) set[i] = <span class="keyword">new</span> HashSet();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : edges) &#123;</div><div class="line">            set[edge[<span class="number">0</span>]].add(edge[<span class="number">1</span>]);</div><div class="line">            set[edge[<span class="number">1</span>]].add(edge[<span class="number">0</span>]);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// use queue to do bfs</span></div><div class="line">        LinkedList&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList();</div><div class="line">        List&lt;Integer&gt; edge_case = <span class="keyword">new</span> ArrayList();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; set.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span>(set[i].size() == <span class="number">1</span>) q.add(i);</div><div class="line">            <span class="keyword">if</span>(set[i].size() == <span class="number">0</span>) edge_case.add(i);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// if cycle</span></div><div class="line">        <span class="keyword">if</span>(q.size() == <span class="number">0</span>) <span class="keyword">return</span> edge_case;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> count = edge_case.size();</div><div class="line">        <span class="keyword">while</span>(count + q.size() &lt; n) &#123;</div><div class="line">            <span class="keyword">int</span> size = q.size();</div><div class="line">            count += size;</div><div class="line">            <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">int</span> node = q.remove();</div><div class="line">                <span class="keyword">int</span> parent = set[node].iterator().next();</div><div class="line">                set[node].remove(parent);</div><div class="line">                set[parent].remove(node);</div><div class="line">                <span class="keyword">if</span>(set[parent].size() == <span class="number">1</span>) q.add(parent);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> q;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Longest Increasing Path in a Matrix</title>
      <link href="/algorithm/longest-increasing-path-in-a-matrix/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本博客作为《算法与设计》课程第 3 周的作业</li><li>题目来源：<a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix" target="_blank" rel="external">LeetCode #329</a></li><li>题目类型：Topological Sort</li><li>编程语言：C++</li><li>运行结果：<img src="/algorithm/longest-increasing-path-in-a-matrix/images/result.png" alt=""></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="/algorithm/longest-increasing-path-in-a-matrix/images/description.png" alt=""></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>本题实质是用 DSP 搜索最长路径。不过没必要对图中每个节点都用 DSP 求一遍最长路径，参考拓扑排序只从入度为 0 的节点开始 DSP，在 DSP 过程中记忆每个节点作为起点的最长路径的长度。</p><p>具体步骤为：</p><ul><li><ol><li>根据矩阵构建邻接表，并记录和更新节点的入度。构建邻接表时，要注意满足题意即：当某节点小于上下左右节点才有一条相应路径。</li></ol></li><li><ol><li>DSP 搜索，搜索入口为入度为 0 的结点。</li></ol></li></ul><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">  HashMap&lt;Integer, List&lt;Integer&gt;&gt; maps = <span class="keyword">new</span> HashMap&lt;Integer, List&lt;Integer&gt;&gt;();<span class="comment">// 有向图的邻接表</span></div><div class="line"><span class="keyword">int</span> lens[];<span class="comment">// 记住每个节点作为起点的最大长度</span></div><div class="line">    </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span>)</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</div><div class="line"><span class="keyword">int</span>[] digree = <span class="keyword">new</span> <span class="keyword">int</span>[rows * cols];<span class="comment">// 入度</span></div><div class="line">lens = <span class="keyword">new</span> <span class="keyword">int</span>[rows * cols];</div><div class="line"></div><div class="line"><span class="comment">// 初始化邻接表</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line">List&lt;Integer&gt; neibors = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line"><span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; matrix[i - <span class="number">1</span>][j] &gt; matrix[i][j]) &#123;<span class="comment">// 上</span></div><div class="line">neibors.add((i - <span class="number">1</span>) * cols + j);</div><div class="line">digree[(i - <span class="number">1</span>) * cols + j]++;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; rows &amp;&amp; matrix[i + <span class="number">1</span>][j] &gt; matrix[i][j]) &#123;<span class="comment">// 下</span></div><div class="line">neibors.add((i + <span class="number">1</span>) * cols + j);</div><div class="line">digree[(i + <span class="number">1</span>) * cols + j]++;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; matrix[i][j - <span class="number">1</span>] &gt; matrix[i][j]) &#123;<span class="comment">// 左</span></div><div class="line">neibors.add(i * cols + (j - <span class="number">1</span>));</div><div class="line">digree[i * cols + (j - <span class="number">1</span>)]++;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (j + <span class="number">1</span> &lt; cols &amp;&amp; matrix[i][j + <span class="number">1</span>] &gt; matrix[i][j]) &#123;<span class="comment">// 右</span></div><div class="line">neibors.add(i * cols + (j + <span class="number">1</span>));</div><div class="line">digree[i * cols + (j + <span class="number">1</span>)]++;</div><div class="line">&#125;</div><div class="line">maps.put(i * cols + j, neibors);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</div><div class="line"><span class="keyword">if</span> (digree[i * cols + j] == <span class="number">0</span>) &#123;<span class="comment">//入度为0的节点为搜索入口</span></div><div class="line"><span class="keyword">int</span> len = dsp(i * cols + j, <span class="number">0</span>);</div><div class="line">max = Math.max(max, len);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> max;</div><div class="line">  &#125;</div><div class="line">    </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dsp</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> depth)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (lens[s] != <span class="number">0</span>)</div><div class="line"><span class="keyword">return</span> lens[s];</div><div class="line"></div><div class="line">List&lt;Integer&gt; neibors = maps.get(s);</div><div class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : neibors) &#123;</div><div class="line">lens[n] = dsp(n, depth++);</div><div class="line">max = Math.max(max, lens[n]);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> max + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kth Largest Element in an Array</title>
      <link href="/algorithm/kth-largest-element-in-an-array/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本博客作为《算法与设计》课程第 2 周的作业</li><li>题目来源：<a href="https://leetcode.com/problems/kth-largest-element-in-an-array" target="_blank" rel="external">LeetCode #215</a></li><li>题目类型：Divide and Conquer</li><li>编程语言：C</li><li>运行结果：<img src="/algorithm/kth-largest-element-in-an-array/images/result.png" alt=""></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>For example,<br>Given [3,2,1,5,6,4] and k = 2, return 5.</p><p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>题目的要求很清晰，就是要求出一个整数数组中第k大的元素。<br>最容易想到的做法，也是最简单粗暴的做法，就是先从大到小排序，然后取排序后数组的第k个元素即可。</p><p>但是仔细一想，这种做法是不是有点浪费了？你将一整个数组排好序，但最终只是利用了第k个元素。<br>所以我们是不是可以找出一个比较节能的算法，使得时间复杂度上做到更优呢？</p><p>排序算法的时间复杂度最快是O(nlogn)，用Quicksort或者Mergesort可以做到。<br>观察一下这道题，从某种程度上来说，它的做法跟排序的做法应该区别不大。<br>Quicksort和Mergesort算法都是来源于分治思想，因此，我们可以以此为切入点。</p><p>假如我们随机地从数组中选取一个元素作为主元（pivot），然后线性遍历一下数组，将其分成三个子数组：</p><ul><li>小于pivot的，记作[small]，假设其长度为small_len</li><li>等于pivot的，记作[equal]，假设其长度为equal_len</li><li>大于pivot的，记作[large]，假设其长度为large_len</li></ul><p>做完分组之后，我们可以这样表示原来的数组：[[small], [equal], [large]]。<br>后面为了实际操作的方便，我将表示为[[small], [large], [equal]]。</p><p>接下来我们可以作出以下的分析：</p><ul><li>如果<strong>k &lt;= large_len</strong>，即有不止k个元素大于pivot，所以pivot是在要找的第k大的元素之后，此时我们继续递归地在[large]子数组中继续寻求第k大的元素</li><li>如果<strong>large_len &lt; k &lt;= large_len + equal_length</strong>，即第k大的元素落在[equal]子区间内，也就是此时对应的pivot</li><li>如果<strong>large_len + equal_length &lt; k</strong>，即[large]和[equal]两个数组的元素数目之和都没有k大，那么我们就还需要在[small]里面找到子数组的第(k - large_len - equal_len)大的元素</li></ul><p>上面三种情况对应的结果是：findKthLargest(初始数组, k) =</p><ul><li>findKthLargest(大于pivot的数组, k)</li><li>pivot</li><li>findKthLargest(小于pivot的数组, k - large_len - equal_len)</li></ul><p>算法其实不复杂，就是下面两步：</p><ul><li>STEP 1. 将数组划分成三个子数组，可参考Quicksort的划分算法<img src="/algorithm/kth-largest-element-in-an-array/images/partition.png" alt=""></li></ul><p>划分时，比Quicksort多出来的一步是：将与主元相等的元素交换到数组的最右边。这也是我上面提到为什么记成[[small], [large], [equal]]的原因了。</p><ul><li>STEP 2. 根据三个子数组的长度判断是否已经取到目标元素，若否则递归求解之</li></ul><p>时间复杂度上，</p><ul><li>最优的情况是每次取到的主元都是当前数组的中位数，这样能使原数组划分后的[large]和[small]的长度大致相同。T(n) = T(n/2) + O(n)，由大师定理得：时间复杂度是O(n)</li><li>最坏的情况当然是每次都取到当前数组的最小值。T(n) = n + (n-1) + … + n/2 = O(n^2)，时间复杂度是O(n^2)</li></ul><p>因此我们定义一种“不错”的情况：选取的主元位置落在元素组的0.25到0.75之间（概率为50%，我们平均需要做两次选取主元操作才能选取到那个“不错”的主元），这时候的时间复杂度存在一个上界：</p><p>T(n) &lt;= T(3n/4) + O(n)</p><p>其中，T(3n/4)是指主元刚刚落在0.25或0.75这两个边界，O(n)是进行分组（线性遍历）时花费的时间。<br>根据大师定理可以得出对应的时间复杂度为O(n)。</p><p>因此我们可以得出结论：</p><ul><li>该算法最坏情况下的时间复杂度为O(n^2)，但是发生的几率极低</li><li>该算法最优情况下的时间复杂度为O(n)，发生的几率也很低</li><li>该算法“不错”情况下的时间复杂度为O(n)，发生的几率很高，可以视作该算法的平均复杂度</li></ul><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> temp = *a;</div><div class="line">  *a = *b;</div><div class="line">  *b = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">choosePivot</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> nums_len)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> nums_len / <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> nums_len, <span class="keyword">int</span> *small_pos, <span class="keyword">int</span> *large_pos)</span> </span>&#123;</div><div class="line">  <span class="comment">// 选择主元</span></div><div class="line">  <span class="keyword">int</span> pivot_pos = choosePivot(nums, nums_len);</div><div class="line">  <span class="keyword">int</span> equal_count = <span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> last_small = <span class="number">0</span>;</div><div class="line">  </div><div class="line">  <span class="comment">// 将主元与数组首元素交换位置</span></div><div class="line">  swap(nums + <span class="number">0</span>, nums + pivot_pos);</div><div class="line"></div><div class="line">  <span class="comment">// 遍历数组，划分成三组</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums_len - equal_count; ++i) &#123;</div><div class="line">    <span class="keyword">if</span> (nums[i] &lt; nums[<span class="number">0</span>])</div><div class="line">      swap(nums + i, nums + ++last_small);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[<span class="number">0</span>])</div><div class="line">      swap(nums + i--, nums + nums_len - equal_count++);</div><div class="line">    <span class="keyword">else</span>;</div><div class="line">  &#125;</div><div class="line">  swap(nums + <span class="number">0</span>, nums + last_small);</div><div class="line">  swap(nums + last_small, nums + nums_len - equal_count);</div><div class="line"></div><div class="line">  <span class="comment">// 获取边界</span></div><div class="line">  *small_pos = last_small - <span class="number">1</span>;</div><div class="line">  *large_pos = nums_len - <span class="number">1</span> - equal_count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> nums_len, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> small_pos, large_pos;</div><div class="line"></div><div class="line">  <span class="comment">// 对数组进行划分，得到三组的边界</span></div><div class="line">  partition(nums, nums_len, &amp;small_pos, &amp;large_pos);</div><div class="line">  <span class="keyword">int</span> small_len = small_pos + <span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> large_len = large_pos - small_pos;</div><div class="line">  <span class="keyword">int</span> equal_len = nums_len - <span class="number">1</span> - large_pos;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (k &lt;= large_len)</div><div class="line">    <span class="keyword">return</span> findKthLargest(nums + small_len, large_len, k);</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (large_len &lt; k &amp;&amp; k &lt;= large_len + equal_len)</div><div class="line">    <span class="keyword">return</span> nums[nums_len - <span class="number">1</span>];</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> findKthLargest(nums, small_len, k - large_len - equal_len);</div><div class="line"></div><div class="line">  <span class="comment">// 如果是Kth Smallest</span></div><div class="line">  <span class="comment">// if (k &lt;= small_len) &#123;</span></div><div class="line">  <span class="comment">//   return findKthLargest(nums, small_len, k);</span></div><div class="line">  <span class="comment">// &#125;</span></div><div class="line">  <span class="comment">// else if (small_len &lt; k &amp;&amp; k &lt;= small_len + equal_len) &#123;</span></div><div class="line">  <span class="comment">//   return nums[nums_len - 1];</span></div><div class="line">  <span class="comment">// &#125;</span></div><div class="line">  <span class="comment">// else &#123;</span></div><div class="line">  <span class="comment">//   return findKthLargest(nums + small_len, large_len, k - small_len - equal_len);</span></div><div class="line">  <span class="comment">// &#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Home</title>
      <link href="/home/"/>
      <content type="html"><![CDATA[<p>Hey, welcome to painterdrown’s Blog!</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/others/hello-hexo/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今晚花了一整晚的事件搭起了这个博客网站。要不第一篇博客，就来分享一下这个过程吧！</p><p>其实之前一直想用Github Pages做个人博客网站，但是由于时间和记忆力的关系就一直搁置着。</p><p>是这学期的《算法设计与分析》课程，老师要求我们每周用写一篇算法博客，作为平时作业。老师推荐用CSDN来写，但是我觉得太丑了，还是想折腾一下自己的博客网站。</p><p>所以呢，最后在张圆圆同学的推荐下，我选择了Hexo + Github Pages来做这件事情。</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li><p>创建自己的github.io仓库</p></li><li><p>安装Hexo，配置网站参数</p></li><li><p>选择主题，配置主题参数</p></li><li><p>添加标签</p></li></ol><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><h3 id="创建自己的github-io仓库"><a href="#创建自己的github-io仓库" class="headerlink" title="创建自己的github.io仓库"></a>创建自己的github.io仓库</h3><p>这一步很简单，直接在Github上面New repository就好了。<br>不过记得repository的名字一定要是username.github.io，其中username是你在Github的用户名。<br>创建完之后也不用把仓库拉到本地。</p><h3 id="安装Hexo，配置网站参数"><a href="#安装Hexo，配置网站参数" class="headerlink" title="安装Hexo，配置网站参数"></a>安装Hexo，配置网站参数</h3><p>Hexo是用Node写的，这对我来说很熟悉，直接用npm安装就可以了。</p><ul><li><p>安装Hexo手脚架</p><p><code>npm install hexo-cli -g</code></p></li><li><p>初始化Hexo博客项目</p><p><code>hexo init blog_project_name</code></p></li><li><p>进入项目目录后，安装Node依赖包：</p><p><code>npm install</code></p></li><li><p>跑起来！</p><p><code>hexo server</code></p></li></ul><p>然后就可以在浏览器访问localhost:4000来进入本地的博客网站啦。<br>在博客项目根目录下的_config.yml里面可以配置参数，过了四级应该能看懂。<br>另外，在_config.yml的deploy一项中，修改为：</p><pre><code>deploy:    type: git    repo: https://github.com/usernmae/username.github.io.git    branch: master</code></pre><p>现在就可以试下把本地的博客网站push到Github Pages上面了：</p><ul><li><p>清除本地缓冲（重要，不然push到Github Pages上与本地的效果可能会相差很大）<br><code>hexo clean</code></p></li><li><p>生成本地博客网站</p><p><code>hexo g</code></p></li><li><p>部署到Github Pages</p><p><code>hexo d</code></p></li></ul><p>期间会提示你输入Github的用户名和密码，然后就可以真正访问username.github.io了！</p><h3 id="选择主题，配置主题参数"><a href="#选择主题，配置主题参数" class="headerlink" title="选择主题，配置主题参数"></a>选择主题，配置主题参数</h3><p>我选择的是<a href="https://github.com/klugjo/hexo-theme-clean-blog" target="_blank" rel="external">clean-blog</a>，先把主题项目clone到本地，再进行参数配置即可。</p><ul><li><p>clone主题项目到本地（记得在博客项目根目录下运行该命令）</p><p><code>git clone https://github.com/klugjo/hexo-theme-clean-blog.git themes/clean-blog</code></p></li><li><p>配置主题参数</p></li></ul><p>其实这一步不是必要的，详见该主题项目的Github。</p><h3 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h3><ul><li><p>添加标签页</p><p><code>hexo new page &quot;tags&quot;</code></p></li><li><p>在source/tags/目录下，编辑刚刚生成的index.md，添加：</p><p><code>type: &quot;tags&quot;</code></p></li><li><p>最后，写博客的时候直接使用标签即可</p><p><code>tags: [tag1, tag2, tag3]</code></p></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>希望这篇文章对想在Github Pages上搭建自己网站的同学有帮助！<br>也希望大家以后没事可以多来看看，假装讨论算法问题。</p><p>最后，告诉你一个小秘密，你看到主页的那张很好看的照片没有？没错，是我拍的。<br>Wow，是时候说一声，晚安。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>台湾游第四天(25th)：只有日月潭咯！</title>
      <link href="/travel/taiwan-2017/day-4/"/>
      <content type="html"><![CDATA[<p>八月25th早晨7点⏰ling ling ling~</p><p>今天的计划嘛，只有去日月潭啦，昨晚说要搭巴士去，看能还要5个多小时！我就感觉到好日子快到头了，不想离开台北😭KFC解决早晨，然后搭捷运🚇（也就是地铁）去台北车站🚉。</p><p><img src="/travel/taiwan-2017/day-4/images/chufa.png" alt=""></p><p>这里的巴士系统很规范，售票处是一个扇形的区域，分好几个扇区，每个扇区是一个巴士公司，我们要去的日月潭只有国光公司的巴士有，不过要等到下午5点钟才有车，所以我们决定改乘高铁🚄了！幸好改变了计划，因为搭高铁到台中只要1个钟，从台中搭巴士到日月潭也只要1个钟，我们中午就到日月潭的民宿了～然后就睡了个午觉，下午1点半出发去日月潭码头搭船🚢。</p><p><img src="/travel/taiwan-2017/day-4/images/riyuetan1.png" alt=""></p><p><img src="/travel/taiwan-2017/day-4/images/riyuetan2.png" alt=""></p><p><img src="/travel/taiwan-2017/day-4/images/riyuetan3.png" alt=""></p><p><img src="/travel/taiwan-2017/day-4/images/riyuetan4.png" alt=""></p><p>见到日月潭的时候，真的觉得它的水很干净也很漂亮——清透碧绿（仔细一点会发现水面上一丢丢乐色都没有的）。幸好今天的太阳🌞不是很晒，潭面吹过来的风儿也是丝丝凉爽。上了游艇⛵️（当然没有电影🎬中很豪华的那种），船上的导游叫绿茶🍵（性别男，可这个外号老让我联想起我的goddess奶茶刘若英，很无赖），他在我们到第一站——忘记叫什么寺了，然后还有很出名的阿婆茶叶蛋吃。据说最火的节假日，阿婆一天能卖出25000颗茶叶蛋哦，真是得财源滚滚哪！</p><p>然后第二站是乌达邵，应该是一个，很有厦门鼓浪屿的感觉。上岸之后有很多吃的东西，我们就买了芋头粿，油炸包菜包，姜丝奶茶，山猪肉炒泡面🍜（其实一条面都没有），味道都还可以啦，吃完就搭船回去了～如果早点过来的话，应该还能去其他码头玩一玩的。个人觉得日月潭的旅游方式设计得还是很不错的，搭船绕着这个潭游一圈，单纯坐船估计要话两个小时，然后沿途就停靠各个码头，上岸玩个半个小时左右就上船继续前往下一个码头⛵️。</p><p><img src="/travel/taiwan-2017/day-4/images/jiejing1.png" alt=""></p><p><img src="/travel/taiwan-2017/day-4/images/jiejing2.png" alt=""></p><p><img src="/travel/taiwan-2017/day-4/images/jiejing3.png" alt=""></p><p><img src="/travel/taiwan-2017/day-4/images/jiejing4.png" alt=""></p><p>玩到下午5点多，会房间休息♨️（打打王者，看看新闻）。八点钟肚子饿了出去觅食，发现基本所有的餐馆都close了！下午其实就有姐姐提醒我们早点找吃的，因为当地人都很早休息，寿命肯定比我们这群习惯熬夜的码农多10年😭！最后找的是万能的7-11解决的晚饭。</p><p>这里有一个很不错的体验跟大家分享一下：晚上的时候有一对兄妹在这里卖艺，男生应该有20岁，女生估计只有10几岁，路人🚶都坐在台阶上听他们唱歌🎤，我也坐下来听了两首：父亲和小幸运（说实话小女孩唱的一般般哈哈哈）。期间有一个香港的爸爸带着他的年龄很小的女儿随着歌声翩翩起舞，把大家都逗得很开心。那个时候我也觉得特别的惬意～</p><p>今天也就到此为止啦，然后下午我在高铁站突发奇想，确定写游记的时候应该要多写一写一些细节的场景，这样的话会比较有趣～下面就试一下：</p><p>#旅行小细节No.1⃣️</p><p>坐巴士的下车的时候，需要把车票🎫交还给司机回收♻️，然后我发现很多人都会主动跟司机说一声谢谢，虽然我们可能会觉得这种时候好像没有必要说谢谢，但他们真的就特别的礼貌！</p><p>#旅行小细节No.2⃣️</p><p>坐高铁抵达台中的时候，有很多陌生人主动上前。一开始我下意识地以为他们是黄牛，后来知道其实他们是很热心的，过来询问我们是否要搭巴士，然后告诉我们前面就可以买票了，赞👍！</p><p>最后 Post 上帅羊的仨图儿：</p><p><img src="/travel/taiwan-2017/day-4/images/ziyang1.png" alt=""></p><p><img src="/travel/taiwan-2017/day-4/images/ziyang2.png" alt=""></p><p><img src="/travel/taiwan-2017/day-4/images/ziyang3.png" alt=""></p>]]></content>
      
      
        <tags>
            
            <tag> travel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>台湾游第三天(24th)：101</title>
      <link href="/travel/taiwan-2017/day-3/"/>
      <content type="html"><![CDATA[<p>早晨9.35，这回没有⏰，昨晚12点睡到现在很满足啦！</p><p>早餐是昨晚在便利商店🏪买的满汉全席牛肉面🍜，注意注意⚠️，这是真·牛肉面，四五块牛肉，最大那一片有1cm厚，跟国内和康康和统统，完全不在一个档次好不好！</p><p><img src="/travel/taiwan-2017/day-3/images/zaocan.png" alt=""></p><p>午饭打算选择地道的卤肉饭，到一家叫矮仔财卤肉饭的店。去到那边真的是生意很好，点了大碗卤肉饭（在我心目中充气量就是小碗，份量真的不多），还有姜丝卤猪脚，卤肉空心菜，豆腐～可能由于我这个潮汕后生仔从小吃够了卤味吧，没有感觉很惊艳。吃到最后把所有东西捞在一起，究极无敌台湾卤肉杂菜饭（by大钊）尝起来👅味道还是棒棒的！👍</p><p><img src="/travel/taiwan-2017/day-3/images/xiezi.png" alt=""></p><p><img src="/travel/taiwan-2017/day-3/images/jiejing1.png" alt=""></p><p><img src="/travel/taiwan-2017/day-3/images/wucan.png" alt=""></p><p>下午来了国父纪念馆，相比昨天的故宫博物馆还是有趣一点，因为是近代的历史比较🈶️兴趣✨～参观了宪兵交接仪式，感觉动作没有国内的兵哥哥整齐2333！想走的时候遇到大雨，干脆进屋开了两局王者yeah✌️然后是到了市政府里面走了一圈，没啥记得的嘿～</p><p><img src="/travel/taiwan-2017/day-3/images/tamen1.png" alt=""></p><p><img src="/travel/taiwan-2017/day-3/images/meinv.png" alt=""></p><p>最后一站，101啦！一进去先是一个奢华商场，负一层是吃的地方，尝到了味道真的很好的牛肉面！😋好吃到全程只顾着吃没说话啦，对了，叫金牌🏅️牛肉面，店前有一个奖杯🏆是台北市长颁发的牛肉面节冠军哦😯！</p><p><img src="/travel/taiwan-2017/day-3/images/wancan.png" alt=""></p><p>101的票用支付宝买的，优惠了50RMB哈哈，支付宝大法好啊！上去之后就还好咯，想象中的夜景🌃，比较遗憾就是室外那一层由于下雨☔️不开放555～</p><p><img src="/travel/taiwan-2017/day-3/images/jiejing2.png" alt=""></p><p><img src="/travel/taiwan-2017/day-3/images/qinglv.png" alt=""></p><p><img src="/travel/taiwan-2017/day-3/images/wangzherongyao.png" alt=""></p><p><img src="/travel/taiwan-2017/day-3/images/gouge.png" alt=""></p><p><img src="/travel/taiwan-2017/day-3/images/hezhao.png" alt=""></p><p>今天大概就这样啦，回到房间开了几局黑，明天估计要坐5个小时的大巴去日月潭，很舍不得这两天的台北！赶紧洗完睡觉啦😪886</p><p><img src="/travel/taiwan-2017/day-3/images/tamen2.png" alt=""></p>]]></content>
      
      
        <tags>
            
            <tag> travel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>台湾游第二天(23th)：美女，救救我的脚！</title>
      <link href="/travel/taiwan-2017/day-2/"/>
      <content type="html"><![CDATA[<p>早上八点30的⏰ling ling ling~</p><p><img src="/travel/taiwan-2017/day-2/images/zaocan.png" alt=""></p><p>在楼下找了家豆浆油条店解决了早餐，其实味道就一般般啦，可能还没有大陆那边好吃！</p><p>吃完已经是10点啦，跟预期的10点到故宫博物馆还是有点差入嘿嘿嘿。于是干脆叫了🚕，20分钟就到那边啦～估计是最近开台北大运会的缘故，很经常能看到高高壮壮的外国小哥哥和小姐姐，嗯没错，小姐姐毕竟也是运动员嘛～</p><p><img src="/travel/taiwan-2017/day-2/images/bowuguan1.png" alt=""></p><p><img src="/travel/taiwan-2017/day-2/images/bowuguan2.png" alt=""></p><p><img src="/travel/taiwan-2017/day-2/images/bowuguan3.png" alt=""></p><p><img src="/travel/taiwan-2017/day-2/images/bowuguan4.png" alt=""></p><p><img src="/travel/taiwan-2017/day-2/images/bowuguan5.png" alt=""></p><p>感觉国民党蒋委员长当时在退往台湾的时候，肯定带来了很多很多的历史宝物和黄金😍毕竟故宫博物馆展出的东西一看你就能感受到，应该不会比国内的差，但是我对这些东西都不怎么感冒，就不浪费笔墨啦！走到了下午快两点，脚已经接近报废…肚子也差不多在咕咕叫了，于是前往了下一个地方找吃的——士东市场（2F）。</p><p>进二楼，有很多大陆少见的自动玻璃门，进出市场都要走全家七十一那种的玻璃门，挺新鲜的2333～二楼中部是卖衣服杂物的商铺，两侧才是吃的地方，各有出口入口。挑了一圈之后，我买了一碗猪肝蛋花汤（70台币）和一碗干拌牛肉面（120台币），注意⚠️！这次吃的是真·牛肉面，🐂肉真的每片有一公分厚，足以在我们学校清真食堂做成三碗牛肉面的肉量哈哈，咬下去的口感自己想象体会吧！</p><p><img src="/travel/taiwan-2017/day-2/images/chide1.png" alt=""></p><p>吃完的下一站是甜品店🍮绿逗薏人，喝了XX（忘记怎么写了）绿豆汤，XX抹茶🍵，绿豆芝麻糊（我点的）。味道嘛还OK，完美的下午茶☕️时间，我们仨开了两局黑～</p><p><img src="/travel/taiwan-2017/day-2/images/jiejing1.png" alt=""></p><p>接下来想在给朋友买些吃的回去，就跑去附近的天母（购物的地方）的Sogo商场。一进去就买了四瓶梅子酒，一瓶爱情💓味的送给子扬和敏欣。里面有一个类似于香港taste的大超市，有很多进口的零食。挑了两片99%的巧克力🍫给我跟我弟弟一人一片开开口，我妹就是一盒hello kitty包装的巧克力✌️</p><p><img src="/travel/taiwan-2017/day-2/images/jiejing2.png" alt=""></p><p><img src="/travel/taiwan-2017/day-2/images/jiejing3.png" alt=""></p><p><img src="/travel/taiwan-2017/day-2/images/jiejing4.png" alt=""></p><p><img src="/travel/taiwan-2017/day-2/images/jiejing5.png" alt=""></p><p>然后时间大概是晚上🌃的7点，来到了台湾最最出名的士林夜市！规模确实比昨晚的宁夏夜市大许多。第一家吃的就是一直碎碎念的蚝仔煎（台湾人读：o a jian），味道嘛还行，比不上家里（潮州）的蚝烙❤️。然后是很好吃的花枝烧，卖它的阿姨长得特别瘦！还有葱油饼（很遗憾找不到郭记的）和蒜香鸡（也很好吃，本人很喜欢吃蒜香的东西），最好来了很出名的辛发亭冰点尝了百香滑冰和花生🥜滑冰，味道挺好的！</p><p><img src="/travel/taiwan-2017/day-2/images/chide2.png" alt=""></p><p><img src="/travel/taiwan-2017/day-2/images/chide3.png" alt=""></p><p><img src="/travel/taiwan-2017/day-2/images/chide4.png" alt=""></p><p>最后的最后（现在我已经很困了），今天一整天处在：脚好酸啊，美女好多啊的状态！台北估计要荣登我心目中的颜值榜榜首了！真的是路上碰到美女的机率非常高！高到离谱！离谱到睡觉😪！累死了，晚安😴🌙⭐️💤！</p><p>WAIT!!! 看下面这张我抓拍得特别好看的街景再走，耶（没错，就是博客的封面图，很赞有没有！）✌️</p><p><img src="/travel/taiwan-2017/day-2/images/jiejing6.png" alt=""></p>]]></content>
      
      
        <tags>
            
            <tag> travel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>台湾游第一天(22th)：初来乍到，好多吃的！</title>
      <link href="/travel/taiwan-2017/day-1/"/>
      <content type="html"><![CDATA[<p>时间：2017年8月22号  暑假AND即将🌀<br><br>坐标：🇨🇳广州中山大学慎思园 to Taipei（此处找不到中华民国旗子emoji）</p><p>早晨6点30，⏰ling ling ling~~~</p><p>和狗哥🐶在食堂匆匆解决了早餐之后，直奔广州南。应该是由于太久没吃早餐了，拉了肚子～很多人排队上大号，我居然还在🚽外面发现了一坨💩！应该是哪个小朋友太急了然后解决在外面，家长真的是…</p><p>顺利上了往珠海的🚄，眯了一觉就到珠海站啦，感觉自己😪的时候嘴巴张的很大，萌萌哒！接着是拱北口岸，过关后会直接坐✈️🚌去🇲🇴国际机场</p><p>到那边已经是中午接近12点了，跟另外一个👦子扬汇合后在百福小厨🍴，点的是烧鸭饭和港式奶茶☕️～味道还行就是死贵了！饭后日常开黑wan3局</p><p>2点钟跑过去登机…此处省略很多字…感觉经历了九九八十一关才上了✈️！飞机上很无聊，印象深刻的就是我肚子要被饿扁了，满脑子在想KFC的吮指鸡块😍～原本16:05的飞机在接近五点钟才起飞，还好没被🌀影响到～</p><p><img src="/travel/taiwan-2017/day-1/images/wo.png" alt=""></p><p>下了飞机后嘛，兑了5000TWD，办了张专门打电话的台湾大哥大卡，狗哥🐶之前机智地在淘宝租了一个随身Wi-Fi，随意上网233333～机场便利商店买了交通万能小霸王——悠游卡。另外还有口香糖，和饭卷垫垫肚子，然后直接买了1819路的🚌来到国宾大饭店站，顺利来到了子晴的民宿这里～</p><p>房间跟airbnb的照片差不多，很干净很舒服！主要是子晴姐姐美美哒👧，走廊说拜拜的时候更是被那时那灯那脸迷住了一小会😍～</p><p><img src="/travel/taiwan-2017/day-1/images/minsu.png" alt=""></p><p>是时候去夜市填饱肚子了！宁夏夜市刚好在附近！到夜市之后印象很深刻：这里的摊位很多，但是又显得格外有秩序，而又不失喧嚣，完全跟国内的集群路边摊是两个模样。</p><p><img src="/travel/taiwan-2017/day-1/images/jiejing1.png" alt=""></p><p><img src="/travel/taiwan-2017/day-1/images/jiejing2.png" alt=""></p><p><img src="/travel/taiwan-2017/day-1/images/jiejing3.png" alt=""></p><p><img src="/travel/taiwan-2017/day-1/images/jiejing4.png" alt=""></p><p>吃的，吃的，还是吃的！吃的花样真多好多多多啊！湾湾的胖友们真是会吃！然而文笔渣渣的在下无法用文字来描绘着缤纷的宁夏吃街，一波深夜毒图收好：</p><p><img src="/travel/taiwan-2017/day-1/images/chide1.png" alt=""></p><p><img src="/travel/taiwan-2017/day-1/images/chide2.png" alt=""></p><p><img src="/travel/taiwan-2017/day-1/images/chide3.png" alt=""></p><p><img src="/travel/taiwan-2017/day-1/images/chide4.png" alt=""></p><p><img src="/travel/taiwan-2017/day-1/images/chide5.png" alt=""></p><p><img src="/travel/taiwan-2017/day-1/images/chide6.png" alt=""></p><p><img src="/travel/taiwan-2017/day-1/images/50lan.png" alt=""></p><p>嗯，暑假😪，明天继续台北之trip！来台第一天，印象很棒，后面的旅程也应该如此😁</p><p>最后附上狗哥唯美帅照 &amp; 子扬～</p><p><img src="/travel/taiwan-2017/day-1/images/gouge.png" alt=""></p><p><img src="/travel/taiwan-2017/day-1/images/ziyang.png" alt=""></p><p>#旅行小细节No.1⃣️</p><p>搭扶手电梯的时候，大家都很自觉地靠右边站。其实在大陆我也听有人讲过应该要这样，但是一直不明白为什么。今天我就看到了，原来不赶时间的人就靠右站，然后赶时间的人就可以在左边快速上下啦！</p>]]></content>
      
      
        <tags>
            
            <tag> travel </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
